# ООП

<details>

<summary>ООП вкратце</summary>

### Три основных принципа

1\. Инкапсуляция

Инкапсуляция предполагает объединение данных (состояния объекта) и методов, которые работают с этими данными, в единую сущность — класс. Это позволяет:

* Скрыть внутреннюю реализацию объекта от внешнего мира.
* Защитить данные от некорректного использования.
* Обеспечить контроль доступа к атрибутам объекта через методы (например, геттеры и сеттеры).

#### 2. Наследование

Наследование — это механизм, позволяющий создавать новый класс на основе уже существующего. Новый класс (наследник) получает свойства и поведение родительского класса, что обеспечивает:

* Повторное использование кода.
* Возможность расширения и модификации функциональности.
* Логическую иерархию классов, где общие черты выносятся в базовый класс, а специфичные — реализуются в производных.

Как при описании отношений двух сущностей определить, когда уместно наследование, а когда — композиция? Можно воспользоваться популярной шпаргалкой: спросите себя, сущность А является сущностью Б? Если да, то скорее всего, тут подойдет наследование. Если же сущность А является частью сущности Б, то наш выбор — композиция.

#### 3. Полиморфизм

Полиморфизм позволяет использовать один и тот же интерфейс для объектов разных классов. Это означает, что:

* Одни и те же методы могут вести себя по-разному в зависимости от того, с каким объектом они вызываются.
* Код становится более универсальным и гибким, так как его можно адаптировать для работы с разными типами объектов без изменения логики.





Любые описанные механизмы, принципы и паттерны, как и ООП в целом не стоит применять там, где это бессмысленно или может навредить. Если рассмотреть случай с синглтоном, то его повсеместное применение без знания дела, стало причиной серьезных архитектурных проблем во многих проектах. И любители забивать гвозди микроскопом любезно его нарекли антипаттерном.&#x20;

К сожалению, в проектировании не существует однозначных рецептов на все случаи жизни, где что применять уместно, а где неуместно. Это будет постепенно укладываться в голове с опытом.



Шутка:\
&#xNAN;_— любую архитектурную проблему можно решить добавлением дополнительного слоя абстракции, кроме проблемы большого количества абстракций._



</details>

## Паттерны проектирования

#### 1. Порождающие паттерны (Creational Patterns)

**Описание:**\
Порождающие паттерны помогают управлять созданием объектов, абстрагируя процесс инстанцирования и делая систему более независимой от конкретных классов.

<details>

<summary>Factory Method</summary>

#### Ключевые идеи фабричного метода

* **Инкапсуляция логики создания:**\
  Клиентский код не знает о конкретных классах, он работает через общий интерфейс или абстрактный класс. Это упрощает замену или добавление новых типов компонентов без изменения клиентской логики.
* **Расширяемость:**\
  При появлении нового типа компонента достаточно создать новый класс и соответствующую фабрику, не затрагивая остальной код приложения.
* **Снижение связности:**\
  Клиентский код зависит только от абстракций, а не от конкретных реализаций, что облегчает тестирование и поддержку.

***

### Пример реализации на TypeScript

Представим ситуацию, когда в приложении нужно создавать разные виды кнопок (например, основная и второстепенная). Для этого можно реализовать фабричный метод следующим образом:

```typescript
// Определяем общий интерфейс для кнопок
interface IButton {
  render(): void;
}

// Конкретные реализации кнопок
class PrimaryButton implements IButton {
  render(): void {
    console.log("Render Primary Button");
    // Здесь может быть логика отрисовки, например, создание HTML-элемента
  }
}

class SecondaryButton implements IButton {
  render(): void {
    console.log("Render Secondary Button");
    // Логика отрисовки другого вида кнопки
  }
}

// Абстрактная фабрика, объявляющая фабричный метод
abstract class ButtonFactory {
  abstract createButton(): IButton;
}

// Конкретные фабрики, создающие нужные типы кнопок
class PrimaryButtonFactory extends ButtonFactory {
  createButton(): IButton {
    return new PrimaryButton();
  }
}

class SecondaryButtonFactory extends ButtonFactory {
  createButton(): IButton {
    return new SecondaryButton();
  }
}

// Клиентский код использует фабрику для создания и отрисовки кнопок
function renderButton(factory: ButtonFactory): void {
  const button = factory.createButton();
  button.render();
}

// Пример использования
renderButton(new PrimaryButtonFactory());   // Выведет: Render Primary Button
renderButton(new SecondaryButtonFactory()); // Выведет: Render Secondary Button
```

В данном примере клиентский код не зависит от конкретных классов кнопок, а использует фабрику для создания нужного объекта. Это позволяет легко добавлять новые виды кнопок, просто реализовав новый класс, удовлетворяющий интерфейсу `IButton`, и создав соответствующую фабрику.

</details>

<details>

<summary>Abstract Factory</summary>

### Основная идея абстрактной фабрики

* **Семейства взаимосвязанных объектов:**\
  Абстрактная фабрика позволяет создавать наборы объектов (например, кнопок, чекбоксов, полей ввода), которые работают вместе и должны соответствовать одному стилю или теме.
* **Изоляция от конкретных реализаций:**\
  Клиентский код использует абстрактный интерфейс фабрики, не зная о конкретных классах создаваемых объектов. Это позволяет легко переключаться между разными семействами компонентов (например, переключать тему интерфейса).
* **Гарантия согласованности:**\
  Благодаря созданию объектов через единую фабрику, обеспечивается, что все компоненты интерфейса будут соответствовать выбранной стилистике и функционалу.

***

### Пример реализации на TypeScript

Представим, что у нас есть два набора UI-компонентов для приложения: светлая (Light) и тёмная (Dark) тема. Каждый набор включает кнопку и чекбокс. Абстрактная фабрика позволяет нам создать объекты, соответствующие нужной теме.

```typescript
// Общие интерфейсы для компонентов
interface Button {
  render(): void;
}

interface Checkbox {
  render(): void;
}

// Конкретные реализации для светлой темы
class LightButton implements Button {
  render(): void {
    console.log("Render Light Button");
    // Здесь может быть логика создания HTML-элемента с классами для светлой темы
  }
}

class LightCheckbox implements Checkbox {
  render(): void {
    console.log("Render Light Checkbox");
    // Логика отрисовки чекбокса в светлой теме
  }
}

// Конкретные реализации для тёмной темы
class DarkButton implements Button {
  render(): void {
    console.log("Render Dark Button");
    // Логика создания кнопки с классами для тёмной темы
  }
}

class DarkCheckbox implements Checkbox {
  render(): void {
    console.log("Render Dark Checkbox");
    // Логика создания чекбокса для тёмной темы
  }
}

// Абстрактная фабрика, объявляющая методы для создания компонентов
interface UIComponentFactory {
  createButton(): Button;
  createCheckbox(): Checkbox;
}

// Фабрика для светлой темы
class LightUIFactory implements UIComponentFactory {
  createButton(): Button {
    return new LightButton();
  }
  createCheckbox(): Checkbox {
    return new LightCheckbox();
  }
}

// Фабрика для тёмной темы
class DarkUIFactory implements UIComponentFactory {
  createButton(): Button {
    return new DarkButton();
  }
  createCheckbox(): Checkbox {
    return new DarkCheckbox();
  }
}

// Клиентский код использует фабрику для создания UI-компонентов
function renderUI(factory: UIComponentFactory): void {
  const button = factory.createButton();
  const checkbox = factory.createCheckbox();
  button.render();
  checkbox.render();
}

// Пример использования: переключение между темами
const currentTheme: 'light' | 'dark' = 'light'; // или 'dark'
const uiFactory: UIComponentFactory = currentTheme === 'light'
  ? new LightUIFactory()
  : new DarkUIFactory();

renderUI(uiFactory);
```

В этом примере клиентский код не зависит от конкретных реализаций компонентов. При изменении темы достаточно передать другую реализацию фабрики, и все созданные объекты автоматически будут соответствовать нужной стилистике.

</details>

<details>

<summary>Builder</summary>

### Основные идеи паттерна Builder

* **Пошаговая сборка:**\
  Позволяет создавать объект в несколько этапов, задавая лишь необходимые параметры на каждом этапе. Это удобно, когда у объекта есть много опций или настройки зависят от условий.
* **Инкапсуляция логики создания:**\
  Вся логика построения объекта находится внутри билдера, что позволяет клиентскому коду не знать о деталях создания.
* **Читаемость и поддержка:**\
  С использованием цепочки вызовов (chaining) код становится интуитивно понятным, так как каждый вызов отражает конкретное действие по настройке объекта.

***

### Структура паттерна Builder

Паттерн состоит из **четырёх ключевых компонентов**:

1. **Продукт (Product)** — объект, который мы создаем.\
   В нашем случае это схема валидации (`ZodSchema` или `YupSchema`).
2. **Строитель (Builder)** — интерфейс или базовый класс, определяющий шаги для создания объекта.\
   У нас это `ValidationBuilder`, который позволяет **постепенно добавлять** поля.
3. **Конкретный строитель (Concrete Builder)** — конкретная реализация шагов создания.\
   В этом примере `ValidationBuilder` работает сразу **для Zod и Yup**.

***

### Разбор кода с позиции паттерна **Builder**

#### **1. Продукт (Product)**:

**Это итоговые схемы валидации (`ZodSchema` или `YupSchema`).**

```typescript
const zodSchema = validationBuilder.buildZod();
const yupSchema = validationBuilder.buildYup();
```

***

#### 2. **Строитель (Builder)**:

**Это сам класс `ValidationBuilder`, который управляет созданием схемы**.

Он позволяет пошагово **добавлять** поля с валидацией и потом **собрать** готовый объект.

```typescript
class ValidationBuilder {
  private zodShape: Record<string, ZodSchema<any>> = {};
  private yupShape: Record<string, yup.AnySchema> = {};

  addField(
    fieldName: string,
    type: FieldType,
    options?: { required?: boolean; min?: number; max?: number }
  ): this {
    let zodSchema: ZodSchema<any>;
    let yupSchema: yup.AnySchema;

    switch (type) {
      case FieldType.STRING:
        ...

      case FieldType.NUMBER:
        ...

      case FieldType.EMAIL:
        ...

      case FieldType.BOOLEAN:
        ...

      default:
        throw new Error("Неподдерживаемый тип поля");
    }

    return this;
  }

  buildZod(): ZodSchema<any> {
    return z.object(this.zodShape);
  }

  buildYup(): yup.ObjectSchema<any> {
    return yup.object().shape(this.yupShape);
  }
}
```

***

#### **3. Использование "Строителя"**

Мы **по шагам** создаем объект, добавляя поля:

```typescript
typescriptКопироватьРедактироватьconst validationBuilder = new ValidationBuilder()
  .addField("username", FieldType.STRING, { min: 3, max: 20, required: true })
  .addField("email", FieldType.EMAIL, { required: true })
  .addField("age", FieldType.NUMBER, { min: 18 });

// Генерируем схему Zod
const zodSchema = validationBuilder.buildZod();
console.log(zodSchema.shape);

// Генерируем схему Yup
const yupSchema = validationBuilder.buildYup();
console.log(yupSchema.describe());
```

### Недостатки и особенности

* **Увеличение количества классов:**\
  Для каждого сложного объекта может потребоваться отдельный класс билдера, что увеличивает количество кода и файлов в проекте.
* **Избыточность для простых объектов:**\
  Если объект имеет всего несколько полей, применение билдера может оказаться избыточным, и прямой вызов конструктора будет предпочтительнее.
* **Переусложнение архитектуры:**\
  При чрезмерном использовании паттерна можно создать лишний уровень абстракции, что усложнит поддержку кода, особенно в небольших проектах.

***

### Когда применять Builder

* **Сложные объекты с множеством опций:**\
  Если ваш компонент или объект имеет много параметров, которые не всегда нужны, использование билдера упрощает создание экземпляра.
* **Пошаговая настройка:**\
  Когда требуется конфигурировать объект в несколько этапов, возможно с дополнительной валидацией или изменением поведения между этапами.
* **Динамическая сборка интерфейсов:**\
  В фронтенд-разработке часто бывает необходимость динамически создавать компоненты с разными конфигурациями (например, модальные окна, формы, карточки), и Builder помогает централизовать эту логику.

</details>

<details>

<summary>Prototype</summary>

### Основные идеи паттерна «Прототип»

* **Клонирование объектов:** Вместо того чтобы создавать новый объект с нуля, можно взять уже существующий объект (прототип) и скопировать его.
* **Экономия ресурсов:** При клонировании не создаются дубликаты однотипных методов и свойств для каждого экземпляра. Это особенно полезно, когда создание объекта является «дорогой» операцией (по памяти или времени).
* **Гибкость:** Прототип позволяет динамически изменять объекты во время выполнения, добавляя или изменяя свойства и методы.
* **Наследование:** В JavaScript механизм прототипного наследования позволяет объектам наследовать свойства и методы от других объектов, что является основой работы многих паттернов.



### Пример без использования паттерна «Прототип»

В этом примере каждый новый объект создаёт свою копию метода, что приводит к дублированию кода и увеличению потребления памяти:

```javascript
function Car(model, year) {
    this.model = model;
    this.year = year;
    // Каждый экземпляр создаёт собственную функцию
    this.getInfo = function() {
        return `Модель: ${this.model}, Год: ${this.year}`;
    };
}

let car1 = new Car("Toyota", 2020);
let car2 = new Car("Honda", 2019);

console.log(car1.getInfo()); // Модель: Toyota, Год: 2020
console.log(car2.getInfo()); // Модель: Honda, Год: 2019
```

**Недостатки:**

* При создании большого количества объектов метод `getInfo` будет дублироваться в памяти для каждого экземпляра, что неэффективно.

***

### Пример с использованием паттерна «Прототип»

Здесь мы выносим общий метод в прототип конструктора, благодаря чему все экземпляры будут ссылаться на один и тот же метод:

```javascript
function Car(model, year) {
    this.model = model;
    this.year = year;
}

// Метод getInfo добавлен в прототип, а не создаётся для каждого экземпляра
Car.prototype.getInfo = function() {
    return `Модель: ${this.model}, Год: ${this.year}`;
};

let car1 = new Car("Toyota", 2020);
let car2 = new Car("Honda", 2019);

console.log(car1.getInfo()); // Модель: Toyota, Год: 2020
console.log(car2.getInfo()); // Модель: Honda, Год: 2019
```

**Преимущества:**

* **Экономия памяти:** Метод `getInfo` создаётся один раз и разделяется всеми экземплярами.
* **Производительность:** Уменьшается время создания объектов, так как не требуется создавать копию метода для каждого объекта.
* **Управляемость:** Легче вносить изменения в метод, поскольку изменение в прототипе сразу отражается на всех объектах.

</details>

<details>

<summary>Singleton</summary>

### Основные идеи паттерна «Синглтон»

* **Единственный экземпляр:** Гарантирует, что класс или объект имеет только один экземпляр в приложении.
* **Глобальная точка доступа:** Предоставляет централизованный и единый доступ к этому экземпляру.
* **Контроль над ресурсами:** Используется для управления ресурсами, которые должны быть уникальными (например, подключение к базе данных, конфигурационные параметры, логгеры).

***

### Пример без использования паттерна «Синглтон»

Если создавать объекты напрямую, каждый вызов конструктора приведёт к созданию нового экземпляра, что может вызвать проблемы с согласованностью данных.

```javascript
function Configuration() {
    this.settings = {
        theme: "dark",
        language: "ru"
    };
}

let config1 = new Configuration();
let config2 = new Configuration();

console.log(config1 === config2); // false
```

**Проблема:**\
При создании нескольких экземпляров конфигурации может возникнуть рассинхронизация настроек: изменения в одном экземпляре не будут отражаться в другом.

***

### Пример с использованием паттерна «Синглтон»

Для создания единственного экземпляра объекта можно использовать немедленно вызываемую функциональную конструкцию (IIFE), которая внутри хранит ссылку на созданный экземпляр.

```javascript
const ConfigurationSingleton = (function() {
    let instance;

    function init() {
        // Приватное состояние и методы
        let settings = {
            theme: "dark",
            language: "ru"
        };

        return {
            // Публичный API
            getSettings: function() {
                return settings;
            },
            setSetting: function(key, value) {
                settings[key] = value;
            }
        };
    }

    return {
        // Метод для получения экземпляра
        getInstance: function() {
            if (!instance) {
                instance = init();
            }
            return instance;
        }
    };
})();

// Пример использования:
let configA = ConfigurationSingleton.getInstance();
let configB = ConfigurationSingleton.getInstance();

console.log(configA === configB); // true

// Изменение через один экземпляр отражается в другом
configA.setSetting("theme", "light");
console.log(configB.getSettings().theme); // light
```

**Преимущества использования синглтона:**

* **Единственность:** Гарантируется, что объект конфигурации создаётся только один раз.
* **Централизованный контроль:** Изменения в объекте отражаются глобально, что упрощает управление состоянием приложения.
* **Экономия ресурсов:** Не происходит лишнего создания экземпляров, что может быть критичным при работе с ресурсозатратными объектами.

</details>

#### 2. Структурные паттерны (Structural Patterns)

**Описание:**\
Структурные паттерны помогают организовать классы и объекты в более крупные структуры, упрощая их взаимодействие.

<details>

<summary>Adapter</summary>

### Основные идеи паттерна «Адаптер»

* **Совместимость:** Позволяет объектам с несовместимыми интерфейсами работать вместе.
* **Инкапсуляция преобразований:** Адаптер скрывает различия между интерфейсами и предоставляет унифицированный API.
* **Гибкость:** Позволяет интегрировать сторонние библиотеки, API или устаревший код в новое приложение без изменения их исходного кода.

### Пример без использования паттерна «Адаптер»

Допустим, у нас есть устаревший сервис, который возвращает данные в неудачном формате:

```javascript
class OldAPI {
  fetchData() {
    return {
      user_data: {
        user_name: "Alice",
        user_age: 25
      }
    };
  }
}

// Новый код ожидает другой формат данных
function displayUser(user) {
  console.log(`Имя: ${user.name}, Возраст: ${user.age}`);
}

const oldApi = new OldAPI();
const user = oldApi.fetchData(); 

// displayUser(user); // ОШИБКА: user.name не определён
```

**Проблема:**\
Функция `displayUser` ожидает данные в формате `{ name, age }`, но старая API возвращает `{ user_data: { user_name, user_age } }`. Вызов функции приведёт к ошибке.

***

### Решение с использованием паттерна «Адаптер»

Создадим адаптер, который преобразует данные в нужный формат:

```javascript
class OldAPIAdapter {
  constructor(oldApi) {
    this.oldApi = oldApi;
  }

  getUser() {
    const oldData = this.oldApi.fetchData();
    return {
      name: oldData.user_data.user_name,
      age: oldData.user_data.user_age
    };
  }
}

const adaptedApi = new OldAPIAdapter(new OldAPI());
const adaptedUser = adaptedApi.getUser();
displayUser(adaptedUser); // Имя: Alice, Возраст: 25
```

**Преимущества адаптера:**

* Код `displayUser` **остался неизменным**.
* `OldAPIAdapter` **скрывает** детали преобразования и делает API совместимым.
* **Можно легко заменить** `OldAPI` на новую версию, просто изменив адаптер.

</details>

<details>

<summary>Bridge</summary>

### Основные идеи паттерна «Bridge»

* **Разделение абстракции и реализации:**\
  Паттерн позволяет отделить высокоуровневую абстракцию от низкоуровневой реализации так, чтобы они могли изменяться независимо друг от друга.
* **Независимое расширение:**\
  Благодаря разделению можно независимо добавлять новые абстракции (расширять бизнес-логику) и новые реализации (например, различные способы рендеринга или платформы).
* **Гибкость:**\
  Изменения в одной иерархии (абстракции или реализации) не требуют изменений в другой, что облегчает масштабирование и поддержку кода.

***

### Пример применения Bridge на JavaScript

Представим, что нам нужно рисовать геометрические фигуры, но способ их отрисовки может варьироваться в зависимости от используемой графической библиотеки или платформы. Для этого выделим две независимые иерархии:

1. **Абстракция:** Определяет, какие фигуры мы можем рисовать (например, круг, квадрат).
2. **Реализация:** Определяет, как именно рисовать фигуру (например, с использованием API первой библиотеки или второй).

#### Шаг 1. Определим интерфейс для реализации рисования

```javascript
// Интерфейс для реализации (DrawingAPI)
class DrawingAPI {
  drawCircle(x, y, radius) {
    throw new Error("Метод не реализован");
  }
}
```

#### Шаг 2. Создадим конкретные реализации

```javascript
// Первая реализация рисования
class DrawingAPI1 extends DrawingAPI {
  drawCircle(x, y, radius) {
    console.log(`API1: Рисую круг с центром (${x}, ${y}) и радиусом ${radius}`);
  }
}

// Вторая реализация рисования
class DrawingAPI2 extends DrawingAPI {
  drawCircle(x, y, radius) {
    console.log(`API2: Рисую круг с центром (${x}, ${y}) и радиусом ${radius}`);
  }
}
```

#### Шаг 3. Определим абстракцию

Абстракция содержит ссылку на реализацию, которую можно подменять.

```javascript
// Абстракция для фигуры
class Shape {
  constructor(drawingAPI) {
    this.drawingAPI = drawingAPI;
  }

  draw() {
    throw new Error("Метод не реализован");
  }
}
```

#### Шаг 4. Создадим конкретную фигуру (расширение абстракции)

Например, класс «Круг», который использует реализацию для рисования.

```javascript
// Конкретная фигура: Круг
class Circle extends Shape {
  constructor(x, y, radius, drawingAPI) {
    super(drawingAPI);
    this.x = x;
    this.y = y;
    this.radius = radius;
  }

  draw() {
    this.drawingAPI.drawCircle(this.x, this.y, this.radius);
  }
}
```

#### Шаг 5. Использование

Теперь можно создавать объекты, комбинируя абстракцию с разными реализациями:

```javascript
// Создаём круг, используя первую реализацию рисования
const circle1 = new Circle(10, 20, 5, new DrawingAPI1());
circle1.draw(); // API1: Рисую круг с центром (10, 20) и радиусом 5

// Создаём круг, используя вторую реализацию рисования
const circle2 = new Circle(15, 25, 8, new DrawingAPI2());
circle2.draw(); // API2: Рисую круг с центром (15, 25) и радиусом 8
```

**Преимущества такого подхода:**

* Абстракция `Circle` и реализация рисования (DrawingAPI1, DrawingAPI2) развиваются независимо.
* При появлении новой графической библиотеки достаточно реализовать новый класс, наследующий `DrawingAPI`, без изменения логики фигур.
* Облегчается поддержка и расширение функциональности.

</details>

<details>

<summary>Composite</summary>

### **Основные идеи паттерна Composite**

* **Рекурсивная структура:** Позволяет строить иерархию объектов, где отдельные элементы и их контейнеры обрабатываются одинаково.
* **Единый интерфейс:** Клиенту не важно, работает ли он с одиночным объектом или с группой.
* **Гибкость:** Можно легко добавлять новые элементы в структуру без изменения существующего кода.
* **Упрощённая работа с деревьями:** Часто используется для представления графических интерфейсов, меню, файловых систем и DOM.

***

#### **Пример древовидной структуры (меню)**

Допустим, у нас есть многоуровневое меню, где пункты могут быть как **простыми ссылками**, так и **вложенными списками**.

**Без Composite (неоптимальный вариант)**

```tsx
const MenuItem = ({ label }) => <li>{label}</li>;

const Menu = ({ items }) => (
  <ul>
    {items.map(item =>
      item.submenu ? (
        <li key={item.label}>
          {item.label}
          <Menu items={item.submenu} />
        </li>
      ) : (
        <MenuItem key={item.label} label={item.label} />
      )
    )}
  </ul>
);
```

**Недостатки:**

* Мы **разделяем** логику рендеринга `MenuItem` и `Menu`, хотя можно было бы использовать общий интерфейс.

***

#### **Использование Composite**

Теперь и `MenuItem`, и `Menu` реализуют **единый интерфейс** – они рендерят `children`.

```tsx
const MenuComponent = ({ label, children }) => (
  <li>
    {label}
    {children && <ul>{children}</ul>}
  </li>
);

const Menu = ({ items }) => (
  <ul>
    {items.map(item => (
      <MenuComponent key={item.label} label={item.label}>
        {item.submenu && <Menu items={item.submenu} />}
      </MenuComponent>
    ))}
  </ul>
);
```

Теперь и `Menu`, и `MenuComponent` **имеют одинаковую структуру** и могут работать как отдельные элементы или контейнеры.

**Использование:**

```tsx
const menuData = [
  { label: "Home" },
  {
    label: "Products",
    submenu: [
      { label: "Phones" },
      { label: "Laptops" },
      { label: "Accessories" }
    ]
  },
  { label: "About" }
];

const App = () => <Menu items={menuData} />;
```

**Преимущества:**

* **Единый интерфейс** для работы с элементами меню.
* **Рекурсивность**: любое меню может содержать вложенные элементы без изменения кода.

</details>

<details>

<summary>Decorator</summary>

### **Основные идеи паттерна Decorator**

* **Гибкое расширение**: Позволяет динамически добавлять функциональность без изменения основного класса.
* **Принцип открытости/закрытости**: Код остаётся открытым для расширения, но закрытым для модификации.
* **Композиция вместо наследования**: Декоратор использует композицию, а не классическое наследование, что делает код более гибким.
* **Многоуровневое декорирование**: Можно накладывать несколько декораторов последовательно.

В React паттерн **Decorator** можно реализовать с помощью **компонентов высшего порядка (HOC - Higher-Order Components)** или **кастомных хуков**.

#### **Пример HOC-декоратора для логирования пропсов**

Допустим, у нас есть базовый компонент `Button`, и мы хотим динамически добавлять логирование его пропсов.

**1. Обычный компонент:**

```javascript
const Button = ({ label, onClick }) => (
  <button onClick={onClick}>{label}</button>
);
```

**2. Декоратор HOC для логирования**

```javascript
const withLogging = (WrappedComponent) => {
  return (props) => {
    console.log("Пропсы компонента:", props);
    return <WrappedComponent {...props} />;
  };
};

// Декорированный компонент
const LoggingButton = withLogging(Button);
```

**3. Использование**

```javascript
const App = () => (
  <LoggingButton label="Click Me" onClick={() => alert("Clicked!")} />
);
```

Теперь, при каждом рендере `LoggingButton`, в консоль будет выводиться лог с его пропсами.

</details>

<details>

<summary>Facade</summary>

### Основные идеи паттерна Facade

* **Упрощение интерфейса:** Клиент не должен разбираться в тонкостях работы сложной системы – фасад предоставляет интуитивно понятный API.
* **Сокрытие сложности:** Детали реализации, взаимодействия между компонентами и последовательность вызовов скрываются за фасадом.
* **Унификация доступа:** Позволяет объединить несколько подсистем под единым интерфейсом, что облегчает их использование и замену.
* **Изоляция клиента от изменений:** При модификации внутренней логики системы изменения минимально затрагивают клиентский код.

### Пример

Опишем три сервиса, отвечающие за разные аспекты работы системы:

```javascript
// AuthService отвечает за аутентификацию
class AuthService {
  login(username, password) {
    console.log(`Аутентификация пользователя: ${username}`);
    // Здесь можно добавить реальную логику аутентификации
    return { token: "abcd1234", user: username };
  }
}

// DataService отвечает за получение данных с сервера
class DataService {
  fetchData(token) {
    console.log(`Получение данных с токеном: ${token}`);
    // Имитация получения данных
    return { data: [1, 2, 3] };
  }
}

// NotificationService отвечает за уведомления
class NotificationService {
  notify(message) {
    console.log(`Уведомление: ${message}`);
  }
}
```

#### Фасад

Фасад теперь реализован так, чтобы каждое действие выполнялось отдельно. Фасад хранит состояние (например, токен и имя пользователя) после входа:

```javascript
class AppFacade {
  constructor() {
    this.authService = new AuthService();
    this.dataService = new DataService();
    this.notificationService = new NotificationService();
    this.token = null;
    this.user = null;
  }
  
  // Метод для аутентификации
  login(username, password) {
    const authResult = this.authService.login(username, password);
    this.token = authResult.token;
    this.user = authResult.user;
    this.notificationService.notify("Вход выполнен успешно!");
    return authResult;
  }
  
  // Метод для получения данных; требует предварительного входа
  fetchData() {
    if (!this.token) {
      throw new Error("Ошибка: Пользователь не аутентифицирован");
    }
    return this.dataService.fetchData(this.token);
  }
}
```

**Преимущества данного подхода:**

* **Модульность:** Каждый метод выполняет только одну задачу.
* **Управляемость:** Клиент сам решает, когда выполнять вход и когда получать данные.
* **Простота поддержки:** При изменении логики одного из сервисов достаточно изменить только соответствующий метод фасада.

</details>

<details>

<summary>Flyweight</summary>

Паттерн **Flyweight** (Легковес) используется для уменьшения расхода памяти при работе с большим числом объектов, которые имеют общие (внутренние) свойства. Идея состоит в том, чтобы разделить объекты на две части:

* **Внутреннее (intrinsic) состояние:** общее для множества объектов (например, цвет, текстура, тип). Эти данные хранятся в одном экземпляре и разделяются между объектами.
* **Внешнее (extrinsic) состояние:** уникальные данные (например, позиция, контекст использования), которые передаются извне при использовании объекта.

Такой подход особенно полезен, если приложение должно создавать сотни или тысячи подобных объектов, поскольку разделение общих данных позволяет значительно сократить потребление памяти.

***

### Пример

Рассмотрим классический пример с деревьями в лесу:\
Каждое дерево имеет уникальные координаты, но тип дерева (название, цвет, текстура) может быть общим для множества экземпляров.

#### Определение Flyweight объектов (тип дерева)

```javascript
// Flyweight объект – содержит общее состояние для деревьев одного типа
class TreeType {
  constructor(name, color, texture) {
    this.name = name;
    this.color = color;
    this.texture = texture;
  }
  
  draw(x, y) {
    console.log(
      `Рисую дерево ${this.name} на координатах (${x}, ${y}) с цветом ${this.color} и текстурой ${this.texture}`
    );
  }
}
```

#### Фабрика Flyweight

Фабрика управляет созданием и кешированием Flyweight объектов:

```javascript
const TreeTypeFactory = {
  treeTypes: {},
  
  getTreeType(name, color, texture) {
    const key = `${name}_${color}_${texture}`;
    if (!this.treeTypes[key]) {
      this.treeTypes[key] = new TreeType(name, color, texture);
    }
    return this.treeTypes[key];
  }
};
```

#### Класс, использующий Flyweight

Каждое дерево хранит только свою уникальную позицию и ссылку на объект типа (Flyweight):

```javascript
class Tree {
  constructor(x, y, treeType) {
    this.x = x;
    this.y = y;
    this.treeType = treeType;
  }
  
  draw() {
    // Передаём внешние данные (координаты) в flyweight для отрисовки
    this.treeType.draw(this.x, this.y);
  }
}
```

#### Контейнер (Лес)

Контейнер управляет группой деревьев:

```javascript
class Forest {
  constructor() {
    this.trees = [];
  }
  
  plantTree(x, y, name, color, texture) {
    const treeType = TreeTypeFactory.getTreeType(name, color, texture);
    const tree = new Tree(x, y, treeType);
    this.trees.push(tree);
  }
  
  draw() {
    this.trees.forEach(tree => tree.draw());
  }
}

// Пример использования:
const forest = new Forest();
forest.plantTree(10, 20, "Дуб", "green", "rough");
forest.plantTree(15, 25, "Дуб", "green", "rough");
forest.plantTree(30, 40, "Сосна", "darkgreen", "smooth");
forest.draw();
```

В данном примере для деревьев типа «Дуб» будет создан один экземпляр класса `TreeType`, который используется всеми деревьями этого типа. Это позволяет экономить память при большом количестве объектов.

</details>

<details>

<summary>Proxy</summary>

### Основные идеи паттерна Proxy

* **Контроль доступа:** Прокси может проверять, кто и когда обращается к реальному объекту.
* **Ленивое создание:** Реальный объект может создаваться только при первом обращении к нему.
* **Кэширование:** Прокси может сохранять результаты дорогостоящих операций, чтобы не выполнять их повторно.
* **Логирование и аудит:** Все вызовы методов могут фиксироваться для отладки или аудита.
* **Безопасность:** Прокси может ограничивать доступ к методам реального объекта.

***

### Пример

Мы создадим функцию-фабрику, которая принимает исходный объект и callback-функцию для обработки записей об изменениях. Прокси перехватывает операции записи (и удаления) и вызывает callback, чтобы сохранить информацию об изменениях.

```javascript
// Функция для создания прокси с логированием изменений
function createTrackedObject(initialObj, onChange) {
  return new Proxy(initialObj, {
    set(target, prop, value) {
      const oldValue = target[prop];
      target[prop] = value;
      const changeRecord = {
        property: prop,
        oldValue,
        newValue: value,
        timestamp: new Date().toLocaleTimeString()
      };
      onChange(changeRecord);
      return true;
    },
    deleteProperty(target, prop) {
      const oldValue = target[prop];
      const result = delete target[prop];
      const changeRecord = {
        property: prop,
        oldValue,
        newValue: undefined,
        action: "delete",
        timestamp: new Date().toLocaleTimeString()
      };
      onChange(changeRecord);
      return result;
    }
  });
}

// Пример использования:
const changeLog = [];

const trackedDoc = createTrackedObject(
  { title: "Initial Title", content: "Initial Content" },
  (changeRecord) => {
    changeLog.push(changeRecord);
    console.log("Изменение:", changeRecord);
  }
);

// Внесем несколько изменений:
trackedDoc.title = "New Title";           // Логируется изменение свойства title
trackedDoc.content = "Updated Content";   // Логируется изменение свойства content
delete trackedDoc.content;                // Логируется удаление свойства content

console.log("Все изменения:", changeLog);
```

В этом примере каждый раз, когда меняется свойство объекта или оно удаляется, вызывается callback, который записывает информацию об изменении в массив `changeLog` и выводит данные в консоль.

</details>

#### 3. Поведенческие паттерны (Behavioral Patterns)

**Описание:**\
Поведенческие паттерны решают задачи эффективного и безопасного взаимодействия между объектами программы.

<details>

<summary>Chain of Responsibility (Цепочка обязанностей) - не описан</summary>



</details>

<details>

<summary>Command (Команда) - не описан</summary>



</details>

