# Подстановки переменных окружения в сборках

В современных проектах на JavaScript/TypeScript (особенно с использованием сборщиков вроде **Webpack**, **Vite**, **Rollup** или **Parcel**) существует практика подстановки **переменных окружения** (Environment Variables) на этапе сборки. Это делается с помощью различных механизмов, вроде `DefinePlugin` (в Webpack) или опции `define` (в Vite/Rollup). В результате, **сборщик** может увидеть «константные» значения, подставленные вместо обращений к переменным, и выполнить ряд оптимизаций, таких как **dead code elimination** (удаление «мертвого» кода, который не выполнится).

Ниже разберёмся, как это работает, и как правильно использовать.

***

#### Суть идеи

1.  **У нас есть условие** в коде, скажем:

    ```js
    if (process.env.NODE_ENV === 'development') {
      console.log("Отладочная информация"); 
    }
    ```
2. **На этапе сборки** мы указываем сборщику: «`process.env.NODE_ENV` равно `'production'`» (или `'development'`), в зависимости от режима сборки.
3. **Сборщик** подставляет (inline) значение, и видит, что `( 'production' === 'development' )` – это `false`.
4. **Dead code elimination**: сборщик понимает, что ветка `if (false) { ... }` не нужна, и вырезает этот код из финального бандла.

В результате:

* Мы **избавляемся** от «лишнего» кода (например, отладочного).
* Уменьшаем размер итогового бандла и убираем потенциально небезопасные логи.

***

#### Webpack: `DefinePlugin`

Если вы используете **Webpack**, вы можете подключить `DefinePlugin` в вашем `webpack.config.js`. Пример:

```js
// webpack.config.js
const webpack = require('webpack');

module.exports = {
  // ... остальная конфигурация
  plugins: [
    new webpack.DefinePlugin({
      'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development'),
      // Можно определить и другие переменные
      '__MY_API_URL__': JSON.stringify('https://api.example.com'),
    })
  ]
}
```

**Что происходит:**

* `DefinePlugin` возьмёт все вхождения `process.env.NODE_ENV` (или `__MY_API_URL__`) в вашем исходном коде и **заменит** их прямым литералом, например:
  * `process.env.NODE_ENV` → `"production"` (строка)
  * `__MY_API_URL__` → `"https://api.example.com"`
*   Далее, если где-то в коде написано:

    ```js
    if (process.env.NODE_ENV === 'production') {
      // ...
    }
    ```

    сборщик превратит это в:

    ```js
    if ('production' === 'production') {
      // ...
    }
    ```

    и, разумеется, `'production' === 'production'` → `true`.\
    Или, если условие наоборот не совпадает, можно получить `false`.
* На следующем шаге (фаза оптимизации) **Webpack** (или Babel, Terser, и т. п.) может применить **dead code elimination** и убрать «невыполнимые» ветви.

***

#### Vite/Rollup: опция `define`

В **Vite**/**Rollup** имеется схожий механизм. К примеру, в `vite.config.js` можно прописать:

```js
// vite.config.js
export default {
  // ...
  define: {
    'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV),
    '__DEBUG__': 'true'
  }
}
```

Это означает, что во всём коде:

* `process.env.NODE_ENV` → `'production'` (или `'development'`, если так указали).
* `__DEBUG__` → `true`.

Сборщик далее при «tree-shaking»/«dead code elimination» может вырезать код, заведомо неисполняемый.

**Пример использования**

```js
if (__DEBUG__) {
  console.log("Debug info");
}
```

Если `__DEBUG__` определён как `false`, сборка увидит `if (false) { ... }` → вырежет ветку.

***

#### 7. Практические советы

1. **Использовать общепринятые переменные**: `process.env.NODE_ENV`, `process.env.DEBUG`, `process.env.API_URL`. Это стандарт, и сборщик/плагины часто делают «умные» оптимизации.
2. **Однозначность**:
   * Пишите `=== 'production'`, а не что-то вроде `(process.env.NODE_ENV || '').startsWith('prod')`. Сборщику сложнее понять такое условие.
3. **Проверяйте, что реально вырезается**:
   * Запустите сборку prod, посмотрите итоговый бандл (сгенерированный JS). Убедитесь, что dev-код не просочился.
4. **Не злоупотребляйте** ветвлениями: большие «if-else» по десятку вариантов могут запутать. Возможно, лучше использовать гибкий конфиг/плагины.

***

#### Вывод

**Define-переменные** (через `DefinePlugin` в Webpack, `define` в Vite/Rollup) — мощный способ подстановки **compile-time** значений, которые сборщик может использовать для удаления неиспользуемого кода (dead code elimination). Самая распространённая практика — подстановка `process.env.NODE_ENV`, различающая **development** и **production**.

* **dev** → оставляет логи/отладку,
* **prod** → убирает лишнее, делая бандл меньше.

Подобный подход не только даёт оптимизацию размера, но и убирает любые dev-вызовы из продакшен-кода, повышая производительность и защищённость (так как внутренние инструменты отладки не «светятся» в проде).
