# Хаки



<details>

<summary>Как выполнить проверку на any? И почему any &#x26; never возвращает never?</summary>

Определить, является ли тип конкретно any, не так просто, потому что any «растворяется» во всех операциях. Один из известных трюков – использовать условный тип с пересечением:

```ts
type IsAny<T> = 0 extends (1 & T) ? true : false;
```

**Почему это работает?**

* Если `T` – это any, то выражение `1 & T` даёт any, а условие `0 extends any` истинно, что приводит к результату `true`.
* Если `T` – не any, то пересечение `1 & T` сохраняет ограничения типа, и `0 extends (1 & T)` обычно не выполняется, возвращая `false`.

Эта конструкция использует тот факт, что any «поглощает» ограничения, что позволяет отличить его от других типов.

**Объединение (Union):**\
При объединении с any (например, `any | string` или `any | number`) итоговый тип становится any, потому что any представляет собой «неограниченный» тип, и любая операция union с ним не ограничивает набор возможных значений.

**Пересечение (Intersection):**\
Аналогично, пересечение с any (например, `any & { a: number }`) всегда даёт any, так как any «отменяет» все дополнительные ограничения. Другими словами, когда один из операндов является any, система типов не может гарантировать дополнительные сведения и выводит any.

**Почему так происходит?**

* **Логика any:** Тип any специально разработан так, чтобы быть максимально гибким. Он допускает присваивание и извлечение значений без проверки, поэтому любые операции с его участием не могут добавить или сузить информацию о типе.
* **Абсорбция:** Любая операция (union или intersection) с участием any «абсорбирует» другой тип, потому что any не накладывает ограничений – это как если бы вы смешивали любое вещество с «безграничным» веществом, которое перекрывает все особенности.

#### Почему any & never даёт never

* **Тип never** – это «нижний» тип, который не имеет ни одного значения. То есть, никакое значение не может быть одновременно типа never, так как never описывает ситуацию, когда значение отсутствует.

При выполнении операции пересечения any & never мы ищем тип значений, которые одновременно могут быть любым (any) и отсутствовать (never). Но поскольку never не содержит ни одного значения, пересечение автоматически оказывается пустым, то есть равным never.



</details>



<details>

<summary>Как проверить, действительно ли два типа одинаковы? IsEqual</summary>

```typescript
type IsEqual<T, U> = (<G>() => G extends T ? 1 : 2) extends <G>() => G extends U ? 1 : 2
	? true
	: false;
```

Мы можем проверить равенство типов, используя «функциональный трюк», который сводится к сравнению двух универсальных функций. Разберем этот трюк подробнее:

Почему именно функция?

1.  **Избежание дистрибутивности:**\
    Если написать условие напрямую с «голым» типом T, например:

    ```ts
    type IsEqual<T, U> = T extends U ? ([U] extends [T] ? true : false) : false;
    ```

    то при наличии union-типа условное выражение может распределиться по его членам. Завернув T в сигнатуру функции, мы ставим его в позицию, где условные типы не распределяются, что делает проверку инвариантной.
2. **Использование универсальных функций:**\
   Функция вида `<G>() => G extends T ? 1 : 2` – это универсальная функция, которая не зависит от конкретного выбора типа G. При сравнении двух таких функций через оператор `extends` TypeScript проверяет, совпадают ли их сигнатуры. Если T и U равны, то обе функции будут эквивалентны, так как для любого G они вернут один и тот же тип (либо 1, либо 2).

</details>



<details>

<summary>Песечение обьектов !== обьект</summary>

Когда вы пишете:

```ts
type Foo = {
  a: number;
};
type Bar = {
  b: number;
  c: boolean;
};

type Merge = Foo & Bar;
Merge !== {
  a: number;
  b: number;
  c: boolean;
}
```

TypeScript создаёт тип, который требует, чтобы объект удовлетворял обоим ограничениям одновременно, то есть имел свойства из `Foo` и из `Bar`. При этом результатом является _пересечение_ двух типов, а не «развернутая» структура с объединёнными свойствами.

#### Что происходит "под капотом"

*   **Intersection Types:**\
    Тип `Merge` — это пересечение `Foo & Bar`. Это означает, что любой объект типа `Merge` должен быть одновременно объектом типа `Foo` и типа `Bar`. Если вы вручную сравните его со «развернутым» типом:

    ```ts
    {
      a: number;
      b: number;
      c: boolean;
    }
    ```

    они, с точки зрения структуры, совпадают. Однако синтаксически TS хранит их как пересечение, а не как уже объединённый тип.
* **Неавтоматическое упрощение:**\
  TypeScript по умолчанию не «упрощает» (flatten) пересечения объектов до единого типа с набором всех свойств. Это может влиять на некоторые операции, например, на проверку равенства типов или на вывод сообщений об ошибках. С точки зрения системы типов, `Foo & Bar` остаётся комбинацией двух отдельных деклараций, даже если она эквивалентна по структуре «расплющенному» типу.

#### Зачем нужен Omit или перебор ключей

Чтобы «развернуть» (flatten) такой тип и получить именно объект с объединёнными свойствами, часто используют один из следующих подходов:

1.  **Mapped Type с Omit**\
    Использование конструкции вроде `Omit<Foo & Bar, never>` заставляет TypeScript перебрать все свойства пересечения и создать новый тип, где все ключи объединены:

    ```ts
    type Flatten<T> = { [K in keyof T]: T[K] };
    type MergedFlattened = Flatten<Foo & Bar>;
    // Теперь MergedFlattened будет равен:
    // { a: number; b: number; c: boolean }
    ```
2.  **Явная итерация по ключам**\
    Аналогичный эффект достигается созданием утилитного типа, который явно перебирает ключи объединения:

    ```ts
    type MergeOverride<T, U> = {
      [K in keyof T | keyof U]: K extends keyof U ? U[K] : K extends keyof T ? T[K] : never;
    };

    type MergedResult = MergeOverride<Foo, Bar>;
    // Результат: { a: number; b: number; c: boolean }
    ```

#### Итог

* **Intersection (`Foo & Bar`)** в TypeScript означает, что объект должен удовлетворять обоим типам, но сам тип остаётся в виде пересечения, а не «расплющенной» структуры.
* **Неупрощённое представление:**\
  Хотя с точки зрения структуры тип `Foo & Bar` эквивалентен `{ a: number; b: number; c: boolean }`, синтаксически они отличаются.
* **Разворачивание типа:**\
  Используя такие конструкции, как `Omit<Foo & Bar, never>` или итерацию по ключам, мы вынуждаем компилятор пересчитать пересечение и получить «развернутый» объектный тип, что упрощает его использование и сравнение.

Таким образом, чтобы добиться именно «слияния» объектов в плоскую структуру, приходится прибегать к дополнительным приёмам, поскольку TS сохраняет пересечение как отдельную конструкцию, а не преобразует его автоматически в объединённый тип с набором всех свойств.

</details>



<details>

<summary>Бивариантный хак с функцией</summary>

В TypeScript существует так называемый «бивариантный хак», который позволяет функциям вести себя нестрого, то есть «бивариантно», по отношению к типам параметров. Это отклонение от строгой контравариантности, которое было введено для повышения удобства и обратной совместимости.

По умолчанию _супертип X_ не может быть передан функции _fn(n:X)_&#x20;

```typescript
type Foo = { foo: number; };
type FooBar = { foo: number; bar: number; };
type FooBarBaz = { foo: number; bar: number; baz: number; };

type FooBarFn = (item: FooBar) => void;

let func: FooBarFn = (item: Foo) => console.log(item);
// OK

let func: FooBarFn = (item: FooBar) => console.log(item);
// OK

let func: FooBarFn = (item: FooBarBaz) => console.log(item);
// Error
```

### Хак

Когда дело доходит до метода объекта, он может получать как надмножество, так и подмножество определенного типа, то есть он бивариантен.\
Чтобы сделать обычную функцию бивариантной, мы должны _«извлечь»_ тип метода и применить его к функции.

```typescript
type Foo = { foo: number; };
type FooBar = { foo: number; bar: number; };
type FooBarBaz = { foo: number; bar: number; baz: number; };

type FooBarHackedFn = {
    bivarianceHack(item: FooBar): void
}['bivarianceHack'];

let func: FooBarHackedFn = (item: Foo) => console.log(item);
// OK

let func: FooBarHackedFn = (item: FooBar) => console.log(item);
// OK

let func: FooBarHackedFn = (item: FooBarBaz) => console.log(item);
```

#### Итог

* **Обычные функции:**\
  Строго проверяются на контравариантность, то есть функция с параметром более узкого типа нельзя присвоить переменной, ожидающей параметр более широкого типа.
* **Методы объектов:**\
  Проверяются бивариантно, что позволяет принимать в качестве параметра метода более узкий тип, чем тот, который заявлен в интерфейсе. Это сделано для удобства и сохранения обратной совместимости с существующими паттернами использования методов.

</details>

