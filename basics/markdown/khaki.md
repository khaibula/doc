# Хаки



<details>

<summary>Как выполнить проверку на any? И почему any &#x26; never возвращает never?</summary>

Определить, является ли тип конкретно any, не так просто, потому что any «растворяется» во всех операциях. Один из известных трюков – использовать условный тип с пересечением:

```ts
type IsAny<T> = 0 extends (1 & T) ? true : false;
```

**Почему это работает?**

* Если `T` – это any, то выражение `1 & T` даёт any, а условие `0 extends any` истинно, что приводит к результату `true`.
* Если `T` – не any, то пересечение `1 & T` сохраняет ограничения типа, и `0 extends (1 & T)` обычно не выполняется, возвращая `false`.

Эта конструкция использует тот факт, что any «поглощает» ограничения, что позволяет отличить его от других типов.

**Объединение (Union):**\
При объединении с any (например, `any | string` или `any | number`) итоговый тип становится any, потому что any представляет собой «неограниченный» тип, и любая операция union с ним не ограничивает набор возможных значений.

**Пересечение (Intersection):**\
Аналогично, пересечение с any (например, `any & { a: number }`) всегда даёт any, так как any «отменяет» все дополнительные ограничения. Другими словами, когда один из операндов является any, система типов не может гарантировать дополнительные сведения и выводит any.

**Почему так происходит?**

* **Логика any:** Тип any специально разработан так, чтобы быть максимально гибким. Он допускает присваивание и извлечение значений без проверки, поэтому любые операции с его участием не могут добавить или сузить информацию о типе.
* **Абсорбция:** Любая операция (union или intersection) с участием any «абсорбирует» другой тип, потому что any не накладывает ограничений – это как если бы вы смешивали любое вещество с «безграничным» веществом, которое перекрывает все особенности.

#### Почему any & never даёт never

* **Тип never** – это «нижний» тип, который не имеет ни одного значения. То есть, никакое значение не может быть одновременно типа never, так как never описывает ситуацию, когда значение отсутствует.

При выполнении операции пересечения any & never мы ищем тип значений, которые одновременно могут быть любым (any) и отсутствовать (never). Но поскольку never не содержит ни одного значения, пересечение автоматически оказывается пустым, то есть равным never.

#### Формальная интерпретация

1. **Подтипность never:**\
   В TypeScript тип never является подтипом любого типа. Это значит, что если X — любой тип, то never⊆X. Но обратное неверно: не каждое значение типа X принадлежит never, так как never не содержит значений.
2. **Интерпретация пересечения:**\
   any\&never означает «значение, которое является одновременно и любым, и отсутствующим». Поскольку нет ни одного значения, удовлетворяющего условию отсутствия (never), итоговое пересечение становится пустым — типом never.

</details>



<details>

<summary>Как проверить, действительно ли два типа одинаковы? IsEqual</summary>

```typescript
type IsEqual<T, U> = (<G>() => G extends T ? 1 : 2) extends <G>() => G extends U ? 1 : 2
	? true
	: false;
```

Мы можем проверить равенство типов, используя «функциональный трюк», который сводится к сравнению двух универсальных функций. Разберем этот трюк подробнее:

Почему именно функция?

1.  **Избежание дистрибутивности:**\
    Если написать условие напрямую с «голым» типом T, например:

    ```ts
    type IsEqual<T, U> = T extends U ? ([U] extends [T] ? true : false) : false;
    ```

    то при наличии union-типа условное выражение может распределиться по его членам. Завернув T в сигнатуру функции, мы ставим его в позицию, где условные типы не распределяются, что делает проверку инвариантной.
2. **Использование универсальных функций:**\
   Функция вида `<G>() => G extends T ? 1 : 2` – это универсальная функция, которая не зависит от конкретного выбора типа G. При сравнении двух таких функций через оператор `extends` TypeScript проверяет, совпадают ли их сигнатуры. Если T и U равны, то обе функции будут эквивалентны, так как для любого G они вернут один и тот же тип (либо 1, либо 2).

Почему возвращаются значения 1 и 2? Это произвольные константные значения, которые помогают отличить ветви условия. Если T и U равны, для любого G результат условного выражения будет одинаковым, и функции окажутся взаимно присваиваемыми.

</details>

