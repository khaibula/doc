# Строгий typescript

Отлично. Я подготовлю статью о том, как с помощью `tsconfig.json` включить максимально строгую проверку в TypeScript, с подробным описанием каждого ключевого параметра. Я также добавлю примеры кода, показывающие поведение с включёнными и отключёнными опциями.

Дай немного времени — скоро вернусь с результатом.

## Максимально строгий режим TypeScript: настройка tsconfig.json

### Введение

TypeScript по умолчанию достаточно снисходителен к вашему коду – многие потенциальные ошибки не отслеживаются компилятором, если не включить специальные флаги. Чтобы задействовать все преимущества статической типизации, рекомендуется **включить строгий режим**. В файле конфигурации **`tsconfig.json`** это делается с помощью опции `"strict": true`. Строгий режим заставляет компилятор применять более жесткие проверки типов, помогая заранее поймать возможные ошибки. Фактически флаг `strict` является **сборником** нескольких отдельных опций компилятора. Ниже мы разберем каждую из этих опций, а также другие **строгие проверки** TypeScript, которые не включаются автоматически флагом `strict`, но их желательно активировать для максимальной строгости.

### Флаг `strict`: включение всех строгих проверок

Опция `strict` включает широкий спектр проверок типов, повышающих надежность кода. Проект в **строгом режиме** потребует более тщательного соответствия типов, но взамен вы получите меньше скрытых ошибок. Установив `"strict": true` в `tsconfig.json`, вы тем самым **активируете сразу несколько строгих правил** компилятора. На данный момент флаг `strict` объединяет следующие ключевые опции (флаги строгой типизации) ([TypeScript: Раскладываем tsconfig по полочкам. Часть 2 — Всё про строгость / Хабр](https://habr.com/ru/articles/557738/)):

* `noImplicitAny`
* `noImplicitThis`
* `alwaysStrict`
* `strictNullChecks`
* `strictFunctionTypes`
* `strictBindCallApply`
* `strictPropertyInitialization`
* `strictBuiltinIteratorReturn`
* `useUnknownInCatchVariables`

Проще говоря, `strict: true` эквивалентно включению (**`true`**) всех перечисленных опций из **группы строгих проверок**. При необходимости любую из них можно выключить вручную, если строгий режим оказался слишком требовательным в конкретном месте. Однако для нового проекта рекомендуется оставить все эти флаги включенными по умолчанию. В будущих версиях TypeScript под флаг `strict` могут добавляться новые проверки, поэтому при обновлении компилятора могут появиться дополнительные ошибки типизации – это нормальное поведение, указывающее на места, требующие внимания.

Ниже мы подробно рассмотрим каждую из опций строгого режима: что она делает, как влияет на работу TypeScript, и приведем пример кода, демонстрирующий разницу при включении и отключении этой опции. Также отдельно разберем дополнительные строгие проверки, **не входящие** в `strict` по умолчанию, но желательные для максимальной строгости.

### Основные флаги строгого режима (Strict Type-Checking Options)

#### `noImplicitAny` – запрет неявного типа _any_

**Что делает:** Флаг `noImplicitAny` запрещает неявное использование типа `any`. Когда TypeScript не может вывести тип переменной или параметра, он по умолчанию присваивает им тип `any` (означающий «произвольный тип»). Опция `noImplicitAny: true` заставляет компилятор выдавать ошибку в таких случаях, требуя явно указать тип или исправить код ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/)) ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/)). Это предотвращает _«замалчивание»_ ошибок, которые могли бы произойти при использовании значения неизвестного типа.

**Влияние на поведение:** С включенным `noImplicitAny` вы будете сразу знать, где компилятор не смог вывести тип. Вам придется либо добавить аннотацию типа, либо изменить код так, чтобы тип становился понятен. Без этого флага некоторые ошибки выявляются только во время выполнения (или не выявляются вовсе), поскольку `any` отключает проверку типов.

**Пример без `noImplicitAny`:**

```ts
function fn(s) {
  // Компилятор **не** выдаст ошибку, s неявно имеет тип any
  console.log(s.subtr(3)); 
}
fn(42);
```

В этом примере параметр `s` не аннотирован. При **`noImplicitAny: false`** компилятор молча считает `s: any`, поэтому строка `s.subtr(3)` (явно опечатка, метода `subtr` нет) не вызывает ошибок при компиляции. В результате, вы сможете вызвать `fn(42)`, и лишь во время выполнения обнаружится, что у числа нет метода `subtr`.

**Пример с `noImplicitAny`:**

```ts
function fn(s) {
  console.log(s.subtr(3));
}
```

```txt
Parameter 's' implicitly has an 'any' type. (TS7006)
```

Если включить `noImplicitAny: true`, то компилятор выдаст ошибку: _"Parameter 's' implicitly has an 'any' type."_ Требуется явно указать тип параметра `s` (или скорректировать код). Например, мы могли бы задать функцию как `function fn(s: string) {...}`, тогда опечатка `s.subtr` сразу станет явной – компилятор сообщит, что у типа `string` нет метода `subtr`. Флаг `noImplicitAny` поэтому повышает _безопасность_, не позволяя пропускать через компиляцию потенциально опасные места.

> **Included in strict:** `noImplicitAny` автоматически включается при `"strict": true` ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/)).

#### `strictNullChecks` – строгая проверка `null` и `undefined`

**Что делает:** Флаг `strictNullChecks` включает **строгое отношение к значениям** `null` и `undefined`. Когда `strictNullChecks: true`, эти значения рассматриваются как самостоятельные типы – их нельзя присвоить переменной другого типа, не указав этого явно. И наоборот, переменную, не допускающую `undefined`, нельзя использовать без инициализации. Если же `strictNullChecks` **выключен** (значение по умолчанию в старых версиях TypeScript), компилятор **игнорирует** `null`/`undefined` при проверке типов ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/)), позволяя обращаться к свойствам и вызывать методы у _возможно_ неопределенных значений. Это упрощает типизацию, но может привести к _ошибкам в runtime_ – например, попытке вызвать метод у `undefined`.

**Влияние на поведение:** С включенным `strictNullChecks` вы обязаны явно обрабатывать случаи, когда переменная может оказаться `null`/`undefined`. Компилятор будет сообщать об ошибке, если вы используете потенциально неопределенное значение без проверки. При отключенном `strictNullChecks` такие ситуации не выявляются, и вы можете получить `TypeError` во время выполнения, если, например, вызовете метод у `null`. Таким образом, строгая проверка null значительно повышает надежность, заставляя программно учитывать _отсутствие значения_.

**Пример (выключено `strictNullChecks`):**

```ts
let name: string = "Alice";
name = null;               // OK, null игнорируется как особый случай
console.log(name.toUpperCase());  // Runtime-ошибка: name теперь null
```

При **`strictNullChecks: false`** компилятор _не_ возражает против присваивания `null` переменной типа `string`. В результате переменная `name` становится `null`, и последующий вызов `name.toUpperCase()` приведет к ошибке уже при запуске (у null нет метода `toUpperCase`). Компилятор не предотвратил эту ситуацию.

**Пример (включено `strictNullChecks`):**

```ts
let name: string = "Alice";
name = null;  
```

```txt
Type 'null' is not assignable to type 'string'. (TS2322)
```

Теперь при **`strictNullChecks: true`** компилятор выдаст ошибку на присваивании `null` строковой переменной: _"Type 'null' is not assignable to type 'string'"_. Чтобы исправить код, нужно либо изменить тип переменной на `string | null` (если она действительно может быть null), либо не присваивать ей null. Аналогично, любые попытки использовать потенциально неопределенное значение вызовут ошибку, пока вы явно не проверите его. Например:

```ts
const names = ["Ann", "Bob"];
const found = names.find(n => n === "Joe");  // тип found: string | undefined
console.log(found.toUpperCase());
```

```txt
Object is possibly 'undefined'. (TS2532)
```

Метод `find` может вернуть `undefined`, и при включенном `strictNullChecks` компилятор об этом предупредит (ошибка TS2532). Нужно, например, добавить проверку:

```ts
if (found !== undefined) {
  console.log(found.toUpperCase());
}
```

С помощью `strictNullChecks` TypeScript не позволяет забыть про `null`/`undefined` – вы либо учитываете их в коде, либо явно заявляете, что их не бывает.

> **Included in strict:** `strictNullChecks` автоматически включается при `"strict": true` (рекомендуется всегда держать `true` для безопасной работы с `null` и `undefined`).

#### `strictFunctionTypes` – строгая вариантность для функциональных типов

**Что делает:** Опция `strictFunctionTypes` включает **строгую проверку присваиваемости для типов функций**. По умолчанию (если флаг выключен), TypeScript более либерален при сравнении функций – особенно в отношении типов параметров – что исторически оставалось для обратной совместимости. В строгом режиме функция одного типа не может быть присвоена переменной другого типа, если их сигнатуры несовместимы **по всем параметрам и возвращаемому значению**. В частности, `strictFunctionTypes: true` делает проверку **контравариантной** для типов параметров функций, не позволяя присвоить функцию, ожидающую более _узкий_ тип, в место, где может быть вызвана с более широким типом аргумента (это предотвратит потенциальные ошибки).

**Влияние на поведение:** С включенным `strictFunctionTypes` компилятор строже отслеживает, можно ли безопасно использовать одну функцию вместо другой. Если флаг выключен, некоторые небезопасные присваивания функций будут разрешены, что может привести к ошибкам при выполнении (вызову функции с неподходящими аргументами). Поэтому для гарантированной типобезопасности рекомендуется включать этот флаг.

**Пример проблемы (без strictFunctionTypes):**

```ts
type HandlerA = (x: number | string) => void;
type HandlerB = (x: number) => void;
let handleAny: HandlerA;
let handleNum: HandlerB = (x) => { console.log(x.toFixed(2)); };

handleAny = handleNum;      // *Разрешено* без strictFunctionTypes
handleAny("hello");         // Runtime-ошибка: внутри вызов handleNum("hello")
```

Здесь `handleNum` – функция, ожидающая только число. Мы присваиваем её переменной типа `HandlerA`, которая должна уметь обрабатывать число **или строку**. Без строгой проверки такой код компилируется (TS позволяет присвоение, считая параметры ковариантными). В результате вызов `handleAny("hello")` пройдет компиляцию, но в runtime попробует передать строку в `handleNum`, что не соответствует ожиданиям и может привести к неправильной работе (в нашем случае попытка вызвать `.toFixed` у строки вызовет ошибку).

**Пример (с strictFunctionTypes):**

```ts
handleAny = handleNum;
```

```typescript
Type '(x: number) => void' is not assignable to type '(x: string | number) => void'. (TS2322)
```

При **`strictFunctionTypes: true`** такое присваивание будет ошибкой: _"Type '(x: number) => void' is not assignable to type '(x: string | number) => void'"_. Компилятор предотвратил небезопасное присвоение. Вам пришлось бы скорректировать код – либо изменить типы, либо логику. Например, возможно, обе функции должны принимать одинаковый тип, либо нельзя было присваивать их друг другу. В целом, `strictFunctionTypes` делает систему типов более корректной с теоретической точки зрения, закрывая дыру, которая могла привести к ошибкам.

> **Included in strict:** `strictFunctionTypes` включается автоматически при `"strict": true` и обычно всегда должен быть активен в строгом режиме.

#### `strictBindCallApply` – строгая проверка методов `bind`, `call` и `apply`

**Что делает:** Данный флаг заставляет компилятор **проверять корректность аргументов** при использовании встроенных функций `.bind()`, `.call()` и `.apply()` у функций. В JavaScript эти методы позволяют вызвать функцию с явным указанием значения `this` и списком аргументов. Без строгой проверки TypeScript позволяет передавать в `call`/`apply` аргументы любого типа (и результат таких вызовов воспринимается как `any`), не соотнося их с истинной сигнатурой функции. Флаг `strictBindCallApply: true` включает сопоставление типов: переданные аргументы должны соответствовать параметрам исходной функции ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/)) ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/)). Иначе говоря, TypeScript будет выдавать ошибку, если вы вызываете функцию через `call/apply` с неправильными аргументами.

**Влияние на поведение:** С `strictBindCallApply` вы получаете те же гарантии типобезопасности при `func.call(...)` или `func.apply(...)`, что и при обычном вызове `func(...)`. Без этого флага можно неправильно использовать метод, и компилятор не предупредит – потенциально вы получите `undefined` или некорректный результат во время выполнения. Включение флага устраняет эту лазейку, делая вызовы через `bind/call/apply` безопаснее.

**Пример (без strictBindCallApply):**

```ts
function add(x: number, y: number): number {
  return x + y;
}

add.call(null, 2, 3);      // OK: корректный вызов, возвращает 5
add.call(null, "2", "3");  // ❗️Нет ошибки при компиляции, но аргументы неверны
```

Без строгой проверки второй вызов `add.call` не вызывает ошибок при сборке. В результате в runtime произойдет попытка сложить строки `"2"` и `"3"`, что вернет строку `"23"` или приведет к непредвиденным результатам. Компилятор этого не предотвратил, так как без флага он трактует вызов `call` с любыми аргументами как допустимый, а возвращаемое значение – как `any` ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/)).

**Пример (с strictBindCallApply):**

```ts
add.call(null, "2", "3");
```

```txt
Argument of type '\"2\"' is not assignable to parameter of type 'number'. (TS2345)
```

При **`strictBindCallApply: true`** компилятор сопоставит типы: функция `add` требует два числа, но переданы строки – возникает ошибка: _"Argument of type '"2"' is not assignable to parameter of type 'number'"_. Аналогично будет проверяться метод `apply` и привязка через `bind`. Например, `add.bind(null, "2")` тоже не пройдет проверку типов. Это гарантирует, что вы вызываете функции с корректными параметрами даже при непрямом вызове.

> **Included in strict:** `strictBindCallApply` входит в состав строгого режима и включается при `"strict": true` ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/)).

#### `strictPropertyInitialization` – обязательная инициализация свойств класса

**Что делает:** Флаг `strictPropertyInitialization` требует, чтобы **каждое свойство экземпляра класса** было инициализировано (присвоено) до того, как конструктор класса завершится. Иначе компилятор выдаст ошибку. Это касается свойств, которые не имеют значения по умолчанию и не помечены как опциональные (`?`) или с _definite assignment assertion_ (`!`). Без этого флага TypeScript позволяет объявить поле в классе без инициализации, что может привести к тому, что после создания объекта какое-то свойство окажется `undefined` (если программист забыл его присвоить). Включение `strictPropertyInitialization: true` предотвращает такие ситуации, заставляя либо сразу задать свойству значение, либо пометить его как необязательное/инициализируемое позже.

**Влияние на поведение:** Когда флаг активен, у вас есть несколько вариантов для каждого поля класса: присвоить ему значение при объявлении, инициализировать внутри конструктора (в каждой его ветке выполнения) или пометить специальным образом, если вы уверены, что оно будет задано до использования. Если этого не сделать, компилятор покажет ошибку. Без флага вы можете забыть инициализировать поле – TypeScript не будет ругаться, и объект получит свойство со значением `undefined`, что часто не то, что ожидалось.

**Пример (с отключенным strictPropertyInitialization):**

```ts
class Point {
  x: number;
  y: number;
  constructor(x: number) {
    this.x = x;
    // свойство y не инициализировано
  }
}
const pt = new Point(5);
console.log(pt.y * 2);  // undefined * 2 -> NaN, логическая ошибка
```

Без строгой проверки этот класс компилируется, хотя свойство `y` нигде не получает значения. При создании `Point` поле `y` будет `undefined`. Дальнейшие операции с `y` (например, попытка умножения) приведут к нежелательным результатам (`NaN`). TypeScript не предупредил об этой проблеме, и мы получили баг.

**Пример (strictPropertyInitialization включен):**

```ts
class Point {
  x: number;
  y: number;
  constructor(x: number) {
    this.x = x;
  }
}
```

```typescript
Property 'y' has no initializer and is not definitely assigned in the constructor. (TS2564)
```

Со строгим флагом компилятор выдаст ошибку: свойство `y` не инициализировано и не имеет значение по умолчанию. Разрешения два: либо задать `y` прямо в конструкторе (например, `this.y = 0`), либо объявить его как опциональное: `y?: number` (тогда `y` может быть `undefined` и код должен это учитывать), либо воспользоваться утверждением уверенности: `y!: number` (означает "я обещаю, что присвою `y` позже"). Таким образом, `strictPropertyInitialization` не дает случайно забыть про инициализацию важных свойств.

> **Included in strict:** Флаг `strictPropertyInitialization` включен в режим `strict: true` и рекомендуется к использованию ([TypeScript: Раскладываем tsconfig по полочкам. Часть 2 — Всё про строгость / Хабр](https://habr.com/ru/articles/557738/)).

#### `noImplicitThis` – неявный `this: any` запрещен

**Что делает:** Опция `noImplicitThis` запрещает использование `this` без явного типа, если его тип выводится как `any`. Проще говоря, если внутри функции или метода контекст `this` не определен однозначно, компилятор попросит указать его тип или привязку. Это предотвращает ошибки, когда вы, например, теряете контекст `this` или используете функцию вне объекта. Без этого флага, если `this` не привязан к конкретному объекту, TypeScript просто считает его типом `any` и не выдает ошибок ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/)).

**Влияние на поведение:** С `noImplicitThis: true` вы получите ошибку там, где раньше `this` молча считался `any`. Особенно часто это бывает в функциях, которые вызываются без объекта, или при присваивании методов переменным. Вам придется либо явно задать аннотацию типа для `this`, либо изменить стрелочную функцию (у которой свой `this` не создается), либо привязать функцию к нужному контексту. Это делает код более понятным и безопасным: вы всегда знаете, к какому объекту относится `this`.

**Пример (без noImplicitThis):**

```ts
function showName() {
  console.log(this.name);
}
const user = { name: "Bob", show: showName };
user.show();       // в этом вызове this укажет на user
const fn = user.show;
fn();              // в строгом JS this станет undefined, но TS не проверяет
```

Без флага компилятор не возражает против использования `this` внутри обычной функции `showName`, хотя вызов `fn()` вне объекта приведет к тому, что `this` будет `undefined` (в строгом режиме JS) или глобальным объектом (в нестрогом). В любом случае, `this.name` в таком вызове некорректен. TypeScript с отключенным `noImplicitThis` не выдает ошибок по этому поводу – он предполагает `this: any`, поэтому обращение `this.name` считается допустимым (любое свойство на `any` разрешено).

**Пример (с noImplicitThis):**

```ts
function showName() {
  console.log(this.name);
}
```

```typescript
'this' implicitly has type 'any' because it does not have a type annotation. (TS2683)
```

При включенном `noImplicitThis` компилятор помечает использование `this` внутри `showName` как ошибку: _"`this` implicitly has type 'any' because it does not have a type annotation."_ Раз ситуация такая, нам надо решить, каким должен быть `this`. Например, можно переписать функцию, указав тип контекста:

```ts
function showName(this: { name: string }) {
  console.log(this.name);
}
```

Теперь функция `showName` явно ожидает быть вызванной в контексте объекта, содержащего строковое свойство `name`. Если мы попробуем вызвать `showName()` без контекста, TypeScript не позволит (требуется привязка `this`). Или, как вариант, можно было сделать `showName` стрелочной функцией внутри объекта `user`, тогда проблем с `this` не возникло бы. В любом случае, `noImplicitThis` сигнализирует о местах, где `this` используется небезопасно.

> **Included in strict:** Флаг `noImplicitThis` также включается автоматически при `"strict": true` ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/)).

#### `alwaysStrict` – включение строгого режима JavaScript

**Что делает:** Хотя не связан напрямую с проверкой типов, флаг `alwaysStrict` полезен в контексте строгого режима. Он заставляет компилятор добавлять директиву `"use strict"` в каждый выходной `.js` файл (или соответствующий модуль) ([TypeScript: Раскладываем tsconfig по полочкам. Часть 2 — Всё про строгость / Хабр](https://habr.com/ru/articles/557738/)). Это означает, что результирующий JavaScript выполняется в **строгом режиме JavaScript** (ES5 strict mode). Строгий режим JS изменяет некоторые семантики языка, делая его более безопасным: например, запрещает неявное создание глобальных переменных, использование зарезервированных слов в качестве имен и т.д.

**Влияние на поведение:** На уровень TypeScript (типизация) `alwaysStrict` не влияет – он влияет на **runtime-поведение** JavaScript-кода. Если он включен, вы защищены от некоторых распространенных ошибок JavaScript. В частности, попытка обратиться к `this` вне какого-либо объекта даст `undefined` (вместо глобального объекта), что предотвращает скрытые ошибки; присваивание в необъявленную переменную вызовет исключение, а не создаст глобальную переменную, и т.п. Обычно, если вы компилируете TS в модули (ES Module), строгий режим JS и так активен. Но для скриптов или старых модулей `alwaysStrict` гарантирует, что `"use strict"` будет вставлен.

**Пример:**

```ts
function f() {
  // в строгом режиме this будет undefined
  // в non-strict – глобальный объект (window)
  console.log(this);
}
f();
```

При включенном `alwaysStrict`, данный код в скомпилированном виде начнется с `"use strict";`, поэтому вызов `f()` выведет `undefined` в консоль (то есть `this` не установлен). Если бы строгий режим JS не был активен, `this` указывал бы на глобальный объект, что редко желаемо. Таким образом, `alwaysStrict` предотвращает подобные неожиданные ситуации. В общем случае **рекомендуется** всегда держать `alwaysStrict: true` (он включается автоматически, если задан `strict: true`).

> **Included in strict:** `alwaysStrict` включается автоматически при `"strict": true` ([TypeScript: Раскладываем tsconfig по полочкам. Часть 2 — Всё про строгость / Хабр](https://habr.com/ru/articles/557738/)). Обычно нет причин отключать его, так как это влияет только на исполняемый JS-код, делая его безопаснее.

#### `strictBuiltinIteratorReturn` – строгий тип возврата итераторов

**Что делает:** Этот менее известный флаг касается встроенных итераторов (например, генераторов, итераторов строк, массивов и т.д.). `strictBuiltinIteratorReturn: true` заставляет TypeScript считать, что у встроенных итераторов тип возвращаемого значения (`return` в генераторе) по умолчанию `undefined`, а не `any`. В стандартной библиотеке JavaScript итераторы (включая генераторы) по умолчанию не возвращают явного значения – если генератор завершился без `return`, считается, что он вернул `undefined`. Без этой опции TypeScript мог бы моделировать возврат как `any` (для универсальности), но с флагом – типизация более точная: возврат считается `undefined` (или указанным типом). Это предотвращает использование неявного `any` в таких ситуациях.

**Влияние на поведение:** Для большинства разработчиков влияние этого флага остается «под капотом». Включив его, вы получите чуть более строгие типы при работе, например, с генераторами. Если вы определяете генератор и не указываете явно, что он возвращает, TypeScript будет знать, что возвращаемый тип – `undefined` (вместо любого типа). Это опять же убирает возможность неявного `any`. Обычно эту опцию включают вместе с остальными для полноты строгого режима.

**Пример:**

```ts
function* myGen() {
  yield 1;
}
const gen = myGen();
const result = gen.return("hello");
```

Если `strictBuiltinIteratorReturn` выключен, тип `result` (объект с результатом итерации) будет содержать поле `value: any` – компилятор не уверен, какой тип может быть возвращен. С включенным флагом TypeScript знает, что наш генератор не предусмотрел возвращаемого значения (тип `never` или `undefined`), поэтому попытка передать `"hello"` может быть помечена как ошибка типизации (например, несоответствие ожидаемому типу). В данном случае `result.value` будет иметь тип `undefined` (а не `any`), что чуть строже, но безопаснее. В реальности вы редко заметите действие этого флага, однако он работает на общее дело строгой типизации.

> **Included in strict:** Опция `strictBuiltinIteratorReturn` включается флагом `strict: true` (начиная с версии, где она появилась; для максимальной строгости её отключать не стоит).

#### `useUnknownInCatchVariables` – неизвестный тип для catch-переменных

**Что делает:** Флаг `useUnknownInCatchVariables` влияет на тип переменной, объявленной в блоке `catch`. По умолчанию (без этого флага) TypeScript присваивает исключению тип `any` – потому что в JavaScript можно бросить что угодно (не только Error). Однако `any` отключает проверку типов, что неидеально. При включенном флаге тип переменной в `catch` будет `unknown` (если явно не задан другой) ([TypeScript strictly typed - Part 1: configuring a project - DEV Community](https://dev.to/cyrilletuzi/typescript-strictly-typed-part-1-configuring-a-project-9ca)). `unknown` – это более безопасный аналог `any`, который требует прежде чем использовать значение, провести проверку типа или привести его. Таким образом, в `catch` вы не сможете напрямую, например, вызвать метод у ошибки, не удостоверившись, что перед вами объект нужного типа.

**Влияние на поведение:** С `useUnknownInCatchVariables: true` вам придется обрабатывать данные из `catch` более осторожно. Например, если вы ловите исключение и хотите вывести свойство `message`, компилятор заставит вас сперва проверить, действительно ли пойманное исключение имеет этот свойство (является объектом типа `Error` или похожим). Без флага вы могли бы писать `console.error(e.message)` и компилятор бы пропустил (ведь `e: any`), но могло оказаться, что было брошено вовсе не Error, и тогда `e.message` – undefined. С флагом вы получите ошибку компиляции на прямом доступе к `e.message` и, как следствие, более надежный код.

**Пример (с флагом):**

```ts
try {
  // ... какой-то код
} catch (e) {
  // e: unknown
  console.log(e.message);
}
```

```typescript
Property 'message' does not exist on type 'unknown'. (TS2571)
```

Компилятор сообщает, что у типа `unknown` нет свойства `message`. Правильно – нужно сначала выяснить, что же за ошибка. Можно сделать:

```ts
if (e instanceof Error) {
  console.log(e.message);
} else {
  console.log("Unknown error", e);
}
```

Теперь корректно: если пойманный объект – экземпляр `Error`, тогда у него точно есть `message`. Либо обработать иные типы. Такой подход способствует надежности. Если же **`useUnknownInCatchVariables` отключен**, переменная `e` имела бы тип `any`, и можно было бы писать `e.message` без ошибок компиляции – но риск нарваться на runtime-ошибку выше.

> **Included in strict:** Начиная с TypeScript 4.4, поведение `useUnknownInCatchVariables` по умолчанию **включено**, когда активирован строгий режим. Поэтому если у вас `"strict": true`, переменные в `catch` блоке уже будут типа `unknown` (можно отключить отдельно, поставив `useUnknownInCatchVariables: false`, но обычно причин нет).

### Дополнительные строгие опции компилятора

Флаг `strict` включает многие важные проверки, но **не все** возможные. Существуют дополнительные опции компилятора, которые не активируются автоматически строгим режимом, но усиливают проверку кода. Для достижения _максимально строгой типизации_ рекомендуется включить и их тоже (установив в `true`). Рассмотрим такие опции и их эффект:

#### `noImplicitReturns` – требование явного возврата из функций

**Что делает:** Флаг `noImplicitReturns` требует, чтобы в **каждой ветке исполнения функции** явно возвращалось значение, если функция должна возвращать что-то (не `void`). Иными словами, функция не должна "заканчиваться" без `return`, если по типу она что-то возвращает. Без этой опции можно написать функцию с ветвлением, в одной ветке делать `return`, а в другой – завершать функцию без `return` (неявно вернется `undefined`), и компилятор не пожалуется. С `noImplicitReturns: true` такой код будет ошибкой – TypeScript укажет, что не во всех случаях возвращено значение ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/)).

**Влияние на поведение:** Включение этой проверки помогает ловить логические ошибки, когда вы забыли вернуть результат из функции в некотором сценарии. Это не столько про типобезопасность, сколько про общий контроль правильности кода. Ваш код станет немного более многословным (нужно убедиться, что везде есть `return` или явно указано возвращаемое значение `undefined` там, где нужно), но вероятность "упустить" возвращаемое значение снижается.

**Пример (без noImplicitReturns):**

```ts
function compare(x: number, y: number): number {
  if (x > y) {
    return 1;
  } else if (x < y) {
    return -1;
  }
  // если x === y, функция не возвращает ничего (undefined)
}
```

Компилятор это скушает, хотя логически функция `compare` в случае равенства ничего не возвращает (то есть вернет `undefined`, хотя по объявлению должна возвращать `number`). В результате `compare(5,5)` вернет `undefined` — возможно, не то, что ожидалось, и без предупреждений.

**Пример (с noImplicitReturns):**

```ts
function compare(x: number, y: number): number {
  if (x > y) {
    return 1;
  } else if (x < y) {
    return -1;
  }
  // Ошибка: не все пути возвращают значение
}
```

```typescript
Function lacks ending return statement and return type does not include 'undefined'. (TS2366)
```

Теперь компилятор выдаст ошибку: _"Function lacks ending return statement and return type does not include 'undefined'"_. Программист сразу увидит проблему и, например, добавит `return 0` в конце функции для случая равенства. Таким образом, `noImplicitReturns` гарантирует, что функции либо всегда что-то возвращают, либо вы объявили их возвращаемый тип как допускающий `undefined`. Это улучшает предсказуемость поведения функций.

> **Not included in strict:** Обратите внимание, `noImplicitReturns` **не входит** в набор флагов, активируемых `strict`. Его нужно включать отдельно (рекомендуемое значение – `true` для более надежного кода).

#### `noFallthroughCasesInSwitch` – предотвращение неявного провала в `switch`

**Что делает:** Этот флаг заставляет компилятор помечать как ошибку ситуации, когда в конструкции `switch` имеется _case_, который переходит (fall through) в следующий case без `break`, `return` или `throw`. В JavaScript, если в конце case не поставить `break`, выполнение пойдет дальше, выполняя код следующего case. Иногда это намеренно, но часто бывает источником ошибок (забыли `break`). При включенном `noFallthroughCasesInSwitch` каждый непустой case должен заканчиваться явным прекращением выполнения текущего блока. Иначе – ошибка компиляции.

**Влияние на поведение:** Включенный `noFallthroughCasesInSwitch` спасает от случайного пропуска `break`. Если вы **намеренно** хотите объединить два case, вы можете просто поставить комментарий `// fallthrough` (компилятор тогда не будет выдавать ошибку на этот переход). В итоге, флаг обеспечивает, что вы не забудете `break` там, где он нужен, улучшая читаемость и корректность `switch` блоков.

**Пример (без noFallthroughCasesInSwitch):**

```ts
switch (value) {
  case 1:
    console.log("one");
  case 2:
    console.log("two");
    break;
}
```

Здесь, если `value === 1`, то будет выведено и "one", и "two" – скорее всего, ошибка, но компилятор TS без флага ничего не скажет.

**Пример (с noFallthroughCasesInSwitch):**

```ts
switch (value) {
  case 1:
    console.log("one");
  case 2:
    console.log("two");
    break;
}
```

```typescript
Fallthrough case in switch. (TS7029)
```

Компилятор выдаст ошибку на case 1: _"Fallthrough case in switch."_. Чтобы исправить, нужно добавить `break;` после `console.log("one")` (или, если действительно нужно поведение падения через case, явно указать это комментарием). Например:

```ts
  case 1:
    console.log("one");
    // fallthrough
```

Таким образом, `noFallthroughCasesInSwitch` делает `switch` более надежным и явно документированным.

> **Not included in strict:** Флаг `noFallthroughCasesInSwitch` не включается опцией `strict` (относится к качеству кода). Его следует включить вручную для проектов с высокими требованиями к надежности.

#### `noUncheckedIndexedAccess` – проверка индексации на возможное отсутствие

**Что делает:** При включении `noUncheckedIndexedAccess` **индексные доступа** к объектам и массивам становятся более строгими. Обычно, если у объекта определен индексный сигнатурный тип или у массива обращение по индексу, TypeScript возвращает конкретный тип без учета того, есть ли такой элемент. С этим флагом компилятор будет добавлять `| undefined` к типу результата при обращении по индексу, если не известно, что индекс существует ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/)) ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/)). Проще говоря, `obj[key]` или `arr[index]` будет иметь тип _"значение или undefined"_, пока вы не доказали обратное. Это делает обязательной проверку существования элемента, исключая ошибку, когда вы пытаетесь получить несуществующее свойство.

**Влияние на поведение:** Код, где вы обращаетесь к масиву по индексу или к объекту по ключу, станет требовать дополнительных проверок или утверждений типов. Например, без этого флага `arr[i]` для массива вида `number[]` считается `number` всегда, а с флагом – `number | undefined` (ведь индекс может быть вне диапазона массива). Аналогично для объектов с индексными сигнатурами (например, словари). Это может повысить надежность, но иногда приводит к более сложному коду с проверками на undefined. В тех случаях, когда вы уверены, что индекс корректен, можно использовать оператор `!` (non-null assertion) или предварительные проверки длины.

**Пример (без noUncheckedIndexedAccess):**

```ts
const names: string[] = [];
let first = names[0];        // тип first: string
console.log(first.toUpperCase());  // runtime-ошибка, first == undefined
```

TypeScript считает `first` строкой, хотя на деле массив пуст и `first` станет `undefined`. Вызов метода `.toUpperCase()` у undefined вызовет ошибку, но компилятор этого не предусматривал.

**Пример (с noUncheckedIndexedAccess):**

```ts
const names: string[] = [];
let first = names[0];        // тип first: string | undefined
first.toUpperCase();
```

```txt
Object is possibly 'undefined'. (TS2532)
```

Теперь компилятор знает, что `names[0]` может быть неопределен, поэтому тип `first` – `string | undefined`. Вызов `first.toUpperCase()` прямо так вызовет ошибку компиляции (TS2532, возможно undefined). Правильный подход:

```ts
if (first !== undefined) {
  console.log(first.toUpperCase());
}
```

либо задать значение по умолчанию, например:

```ts
let firstName = names[0] ?? "(нет имени)";
console.log(firstName.toUpperCase());
```

В результате мы избежим попытки вызвать метод у `undefined`. Флаг `noUncheckedIndexedAccess` делает подобные места очевидными и стимулирует обработку случаев отсутствия значения. Однако он может быть чересчур строгим для некоторых – в большом проекте множество обращений к массивам потребует изменений. Тем не менее, для **максимальной строгости** его включение оправдано, так как значительно повышает уровень гарантированной безопасности.

> **Not included in strict:** Этот флаг не включается автоматически строгим режимом ([TypeScript: Раскладываем tsconfig по полочкам. Часть 2 — Всё про строгость / Хабр](https://habr.com/ru/articles/557738/)). Его нужно активировать отдельно (`true`), если вы хотите воспользоваться данной проверкой.

#### `exactOptionalPropertyTypes` – точное трактование опциональных свойств

**Что делает:** По умолчанию, если в интерфейсе или типе свойство помечено как опциональное (`?`), TypeScript разрешает не только _отсутствие_ этого свойства, но и явное присваивание значения `undefined`. Иными словами, тип свойства `prop?: T` трактуется компилятором фактически как `T | undefined`. Флаг `exactOptionalPropertyTypes: true` меняет это поведение ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/)). С ним опциональное свойство рассматривается строго: либо свойство присутствует со значением типа `T`, либо его нет вовсе. Явно присвоить `undefined` такому свойству не допускается, если в определении типа `undefined` не указан.

**Влияние на поведение:** Эта проверка предотвращает смешивание понятий _«свойство отсутствует»_ и _«свойство присутствует со значением undefined»_. В JavaScript эти ситуации различаются (метод `obj.hasOwnProperty` или оператор `in` отличат их). Без флага TypeScript не различал их – `undefined` приравнивался к отсутствию. С флагом разработчик должен явно указать `| undefined` в типе, если планирует присваивать `undefined`. Код, где опциональным свойствам присваивается `undefined`, теперь потребует обновления (либо убрать такие присваивания, либо добавить `undefined` в тип).

**Пример (по умолчанию):**

```ts
interface Options {
  mode?: "dark" | "light";
}
const opts: Options = {};
opts.mode = undefined;  // допустимо, mode просто станет отсутствовать
```

Без флага это компилируется: свойство `mode` рассматривается как `"dark" | "light" | undefined`.

**Пример (с exactOptionalPropertyTypes):**

```ts
interface Options {
  mode?: "dark" | "light";
}
const opts: Options = {};
opts.mode = undefined;
```

```typescript
Type 'undefined' is not assignable to type '\"dark\" | \"light\"'. (TS2412)
```

Ошибка: _"Type 'undefined' is not assignable to type '"dark" | "light"'..."_. Компилятор требует либо не присваивать ничего (т.е. удалить свойство, установив его отсутствие), либо изменить определение типа на `mode?: "dark" | "light" | undefined` если действительно задумано значение `undefined`. Таким образом, включенный `exactOptionalPropertyTypes` заставляет явно моделировать ситуацию "свойство установленно в undefined" vs "свойство отсутствует". Это повышает строгость соответствия типам, хотя и требует чуть больше внимания при дизайне типов.

> **Not included in strict:** Данный флаг не включается опцией `strict` (введен в новых версиях как дополнительная строгая проверка). Для максимально строгого режима его рекомендуется включить вручную (`true`) ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/)).

#### `noPropertyAccessFromIndexSignature` – запрет dot-нотации для индексных свойств

**Что делает:** Флаг `noPropertyAccessFromIndexSignature` запрещает обращаться к свойствам объектов через точку, если эти свойства не перечислены явно в его типе, а могут существовать только благодаря **индексной подписи** (index signature). Индексная подпись вида `[key: string]: U` в интерфейсе позволяет объекту иметь произвольные дополнительные свойства типа `U` с любым именем. По умолчанию TypeScript допускает доступ к таким свойствам как через скобки, так и через точку. Однако доступ через точку к неявно объявленному свойству может быть опечаткой: вы могли думать, что свойство есть, а его нет (тогда вернется `undefined`). С флагом `noPropertyAccessFromIndexSignature: true` **требуется** использовать скобочную нотацию (`obj["foo"]`) для любых свойств, не указанных явно в типе ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/)) ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/)). Это сделано, чтобы обратить внимание разработчика: такое свойство не гарантировано, оно попадает под индексную подпись.

**Влияние на поведение:** С этой опцией, попытка написать `obj.someProp` вызовет ошибку, если `someProp` не перечислено явно в интерфейсе типа `obj`, даже если у типа есть `[key: string]: ...`. Нужно писать `obj["someProp"]`. Фактически, dot-нотация разрешена только для тех ключей, которые явно объявлены. Это предотвращает случайные опечатки (например, написали `user.emal` вместо `user.email` – без флага TS бы решил, что это index signature и отдал тип по умолчанию, а с флагом – скажет, что `emal` нет). Кроме того, это делает код более понятным: когда видишь `obj["dynamicKey"]`, сразу ясно, что доступ по произвольному ключу.

**Пример:**

```ts
interface User {
  login: string;
  email: string;
  [key: string]: string;
}
const user: User = { login: "jsmith", email: "jsmith@example.com" };
const username = user.name;       // ключ "name" не объявлен, но индексная сигнатура позволяет
```

Без `noPropertyAccessFromIndexSignature` компилятор не выдаст ошибку на `user.name`. Тип `username` будет считаться `string` (так как по индексной подписи все неопознанные свойства – строки). Если же реального свойства `name` нет, `username` станет `undefined` при выполнении – потенциальная ошибка, которую мы не заметили.

С включенным флагом компилятор выдаст ошибку на `user.name`: нужно использовать `user["name"]` если вы действительно хотите достучаться до произвольного свойства. То есть:

```ts
const username = user["name"];  // тип username: string (| undefined, если в сочетании с noUncheckedIndexedAccess)
```

Теперь очевидно, что доступа по строковому ключу нет в контракте типа. Если одновременно включен `noUncheckedIndexedAccess`, то тип `username` будет `string | undefined`, что еще яснее укажет на необходимость проверки.

> **Not included in strict:** `noPropertyAccessFromIndexSignature` не включен в `strict` по умолчанию ([TypeScript: Раскладываем tsconfig по полочкам. Часть 2 — Всё про строгость / Хабр](https://habr.com/ru/articles/557738/)) (этот флаг считается специфичным). Для максимальной строгости его следует включить вручную.

#### `noImplicitOverride` – требование override для перекрытия методов

**Что делает:** Флаг `noImplicitOverride` касается **классов и наследования**. Если он включен, то когда в производном классе вы определяете метод, который имеет такой же идентификатор, как метод (или свойство) в базовом классе, компилятор потребует явно пометить его ключевым словом `override`. Если этого нет – будет ошибка. Таким образом, вы никогда не "переопределите" метод родителя _неявно_. Без этой опции легко пропустить, что метод в потомке совпал по имени с методом предка (например, опечаткой или по совпадению) – TypeScript по умолчанию просто считает, что вы _переопределили_ метод, но не обращает на это внимания. С `noImplicitOverride` вы либо помечаете намеренное переопределение `override`, либо, если забыли это сделать, получаете ошибку и осознаете ситуацию.

**Влияние на поведение:** Этот флаг делает код на классах более явным и устойчивым к рефакторингу. Если, например, базовый класс переименует метод или изменит его сигнатуру, а потомок все еще содержит старое определение, без `noImplicitOverride` вы об этом не узнаете – у потомка просто будет свой независимый метод, а не override родительского (может привести к логическим ошибкам). С `noImplicitOverride` же компилятор сообщит об ошибке, что у вас указан `override` для метода, которого больше нет в родителе. Это сигнал к тому, что нужно обновить потомок тоже. То же самое в обратную сторону: если забыли написать `override` при переопределении, компилятор напомнит.

**Пример:**

```ts
class Animal {
  speak() {
    console.log("Generic animal sound");
  }
}
class Dog extends Animal {
  speak() {
    console.log("Woof!");
  }
}
```

Без `noImplicitOverride` все хорошо – `Dog.speak` переопределяет `Animal.speak`. Теперь представьте, что базовый метод переименовали: `speak` -> `makeSound`. В Dog остался `speak()`, но он уже **не** переопределяет ничего, это просто отдельный метод. Такой разрыв может остаться незамеченным компилятором, и функциональность нарушится (Dog больше не будет выдавать звук через механизм базового класса).

С `noImplicitOverride` код `Dog extends Animal { speak() { ... } }` вызовет ошибку компиляции: _"This member overrides a member in the base class 'Animal', but no override modifier is specified."_ Нужно написать:

```ts
class Dog extends Animal {
  override speak() {
    console.log("Woof!");
  }
}
```

Теперь переименование `Animal.speak` в будущем сразу приведет к ошибке на классе Dog: метод помечен как override, а соответствующего базового больше нет. Это позволит быстро отследить проблему и поправить (переименовать override или удалить, если не нужен). Таким образом, `noImplicitOverride` – отличный инструмент для поддержания согласованности между классами-предками и наследниками.

> **Not included in strict:** Флаг `noImplicitOverride` не включается через `strict` (его нужно указывать вручную, появился в TypeScript 4.3). Для максимальной строгости в ООП-коде рекомендуется включить.

#### `noUnusedLocals` и `noUnusedParameters` – неиспользуемый код под запретом

**Что делают:** Эти два флага относятся скорее к **чистоте и качеству кода**. `noUnusedLocals` генерирует ошибку, если локальная переменная объявлена, но нигде не используется в функциях/блоках. `noUnusedParameters` – аналогично для параметров функции: если параметр не используется внутри функции, компилятор об этом скажет. Эти проверки помогают убрать "мертвый код": переменные, которые были определены, но не пригодились (возможно, остались после рефакторинга), и параметры, которые не нужны (или забыты). Такие вещи не влияют на выполнение программы, но могут указывать на ошибки или просто захламляют код.

**Влияние на поведение:** Включение этих флагов заставит вас удалять неиспользуемые переменные и параметры, либо помечать их специальным образом, если они нужны для интерфейса, но не используются. Например, иногда функция должна соответствовать определенному типу с несколькими параметрами, но не все используются – тогда неиспользуемые можно назвать `_param` (начиная с подчеркивания), и компилятор не будет считать их «неиспользованными» (TS не ругается на переменные, имя которых начинается с `_`). В целом, код станет чище и понятнее.

**Пример (с включенными флагами):**

```ts
function calc(x: number, y: number): number {
  let result = x * 2;
  return x;
}
```

```typescript
'result' is declared but its value is never read. (TS6133)  
'y' is declared but its value is never read. (TS6133)
```

Компилятор укажет, что переменная `result` и параметр `y` не используются. Действительно, возможно, это ошибка – мы хотели вернуть `result`, а по ошибке возвращаем `x`. Такие места сразу становятся заметны. Исправляем код или убираем лишнее.

**Пример (исправленный):**

```ts
function calc(x: number): number {
  const result = x * 2;
  return result;
}
```

Теперь нет лишних параметров и локальных переменных. Если же, например, параметр требуется по сигнатуре, но не нужен, можно сделать:

```ts
function handler(event: Event, _context: any) {
  console.log(event.type);
}
```

Здесь `_context` не используется, но благодаря началу имени с `_` компилятор (и многие линтеры) не будут ругаться.

> **Not included in strict:** Эти опции относятся к **группе проверок качества (Lint)**, и они не входят в `strict`. Их настраивают отдельно. Для максимальной строгости кода, конечно, стоит их активировать (значения `true`).

### Рекомендуемая конфигурация tsconfig.json

Чтобы включить **максимально строгий режим** в TypeScript, удобнее всего начать с опции `"strict": true` – она сразу активирует основную группу строгих проверок типов. Затем в том же `tsconfig.json` явно добавить остальные важные флаги, которые `strict` не включает автоматически. Ниже приведен пример конфигурации:

```json
{
  "compilerOptions": {
    "strict": true,                     // включает все базовые строгие проверки типов
    // Дополнительные строгие проверки:
    "noUncheckedIndexedAccess": true,   // индексные обращения возвращают T | undefined
    "exactOptionalPropertyTypes": true, // различать отсутствие свойства и undefined
    "noImplicitReturns": true,          // все пути в функции должны возвращать значение
    "noFallthroughCasesInSwitch": true, // предупреждать о переходе между case без break
    "noUnusedLocals": true,            // ошибка при неиспользуемых переменных
    "noUnusedParameters": true,        // ошибка при неиспользуемых параметрах функций
    "noImplicitOverride": true,         // требовать явно помечать переопределенные методы
    "noPropertyAccessFromIndexSignature": true // запрет доступа obj.prop к индексным свойствам
  }
}
```

В такой конфигурации:

* Флаг `"strict": true` сам включает: `noImplicitAny`, `noImplicitThis`, `alwaysStrict`, `strictNullChecks`, `strictFunctionTypes`, `strictBindCallApply`, `strictPropertyInitialization`, `strictBuiltinIteratorReturn`, `useUnknownInCatchVariables` – их можно не дублировать в файле, они уже активны. ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/)) ([TypeScript: TSConfig Reference - Docs on every TSConfig option](https://www.typescriptlang.org/tsconfig/))
* Остальные опции установлены вручную на `true`, так как по умолчанию они `false`. Именно эти флаги дополняют строгий режим до максимально возможного уровня проверки.

**Примечание:** В редких случаях некоторые из дополнительных проверок могут быть слишком строгими для вашего проекта. Например, `noUncheckedIndexedAccess` в большом коде может потребовать множества изменений. Однако если цель – максимально надёжный код, имеет смысл потратить время на приведение проекта в соответствие с этими правилами. Все перечисленные опции (и включенные в `strict`) нацелены на выявление потенциальных багов на этапе компиляции, что значительно экономит время отладки.

Наконец, обратимся к тому, **какие опции включаются `strict` автоматически, а какие – нет**. Опции, перечисленные в разделе про основной строгий режим (`noImplicitAny`, `strictNullChecks`, `strictFunctionTypes` и т.д.), — **активируются** при `"strict": true`. Вам не нужно их перечислять по отдельности, если только вы не хотите отключить какую-то из них избирательно. В свою очередь, такие опции как `noImplicitReturns`, `noUnusedLocals` и другие из раздела дополнительных – **не входят** в группу `strict` ([TypeScript: Раскладываем tsconfig по полочкам. Часть 2 — Всё про строгость / Хабр](https://habr.com/ru/articles/557738/)). Их необходимо включать вручную. Поэтому для полного строгого режима комбинируйте `"strict": true` с явным указанием дополнительных флагов.

Подводя итог: **максимально строгий режим TypeScript** достигается установкой `"strict": true` и всех связанных опций строгой проверки в значение `true`. Это обеспечит наиболее полное статическое анализирование вашего кода. Такой подход может выявить больше ошибок на стадии компиляции и сделает ваш TypeScript-проект более надежным и понятным в сопровождении.
