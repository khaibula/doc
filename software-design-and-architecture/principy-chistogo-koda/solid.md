# SOLID

### 1. Single Responsibility Principle (SRP)

**Принцип единственной ответственности**

> У класса (или модуля) должна быть единственная причина для изменения.

#### Суть и примеры

* Каждый класс или модуль решает **одну конкретную задачу**. Если у класса несколько обязанностей (например, и логика отправки письма, и логика сохранения письма в базу, и логика валидации данных), то при изменении одной части может пострадать другая.
* Когда объект выполняет сразу много функций, он усложняется: становится слишком большим («God object») и ломается при малейшем изменении одной из логик.

#### Как применять

* **Разделять** логику по более мелким, осмысленным классам/методам. Например:
  * Класс `EmailSender` занимается только отправкой.
  * Класс `EmailRepository` — сохранением.
  * Класс `EmailValidator` — проверкой корректности.
* Это упрощает поддержку и **тестирование**: каждый класс проверяем на его узком фокусе.

***

### 2. Open/Closed Principle (OCP)

**Принцип открытости/закрытости**

> Программные сущности (классы, модули, функции) должны быть **открыты для расширения**, но **закрыты для модификации**.

#### Суть и примеры

* При добавлении новых возможностей нам не хочется переписывать (модифицировать) уже **рабочий** код, который, возможно, протестирован и стабилен.
* Пример: у нас есть метод, который обрабатывает несколько «форм оплаты» (например, кредитка, PayPal). Если нужно добавить «новую оплату (Crypto)», не стоит лезть в метод со `switch` и дописывать ветку. Лучше использовать **абстракцию** (интерфейс/стратегию/полиморфизм) и добавить новую реализацию, не меняя сам уже проверенный метод.

#### Как применять

* Использовать **полиморфизм** (наследование или интерфейсы) и **паттерны** (Strategy, State, Factory).
* Код, который выбирает нужную реализацию, «не трогается»; мы просто даём ему новый «плагин» – класс или модуль, соответствующий контракту (интерфейсу).
* Так мы «расширяем» функциональность, **не** ломая уже работающие модули.

***

### 3. Liskov Substitution Principle (LSP)

**Принцип подстановки Барбары Лисков**

> Объекты в программе должны быть заменяемы экземплярами их подтипов, **без** нарушения корректности работы.

#### Суть и примеры

* Если у нас есть базовый класс `Base` и наследник `Sub`, то везде, где используется `Base`, мы можем подставить `Sub`, **не** ломая логику.
* Классический пример нарушения: `Rectangle` и `Square`. Если `Square` наследуется от `Rectangle` и мы переопределяем ширину и высоту так, чтобы всегда `width === height`, это может ломать код, который рассчитывает поведение прямоугольника при отдельном изменении ширины или высоты.
* При нарушении LSP код, ожидающий «поведение базового класса», обнаруживает «особое» поведение наследника, что вызывает ошибки или аномалии.

#### Как применять

* Наследник должен полностью **соблюдать** контракт родителя:
  * Не ослаблять инварианты, не вводить неожиданное поведение.
  * Методы родителя работают предсказуемо и для наследника.
* Часто лучше использовать **композицию** вместо наследования, если не можем гарантировать соблюдение LSP.

***

### 4. Interface Segregation Principle (ISP)

**Принцип разделения интерфейсов**

> Клиенты не должны зависеть от методов, которые они не используют.

#### Суть и примеры

* Если интерфейс слишком «толстый» (например, `IMegaPrinter` с методами `print`, `scan`, `fax`, `copy`, и при этом у вас есть принтер, который умеет только печатать и сканировать, но не умеет факсить), то реализация будет вынуждена «заглушать» лишние методы.
* Это усложняет код. Клиент, нуждающийся только в методе `print`, волей-неволей тянет весь интерфейс.
* Принцип: **лучше несколько мелких, специализированных интерфейсов**, чем один универсальный.

#### Как применять

* Разделять большой интерфейс на несколько «ролевых» контрактов.
  * Например, `IPrinter`, `IScanner`, `IFax` отдельно, а нужный класс реализует ровно то, что ему требуется.
* Это упрощает реализацию и тестирование: каждая реализация берёт на себя только нужный функционал.

***

### 5. Dependency Inversion Principle (DIP)

**Принцип инверсии зависимостей**

> Модули верхнего уровня не должны зависеть от модулей нижнего уровня. **Оба** типа модулей должны зависеть от **абстракций**.\
> Абстракции не должны зависеть от деталей. **Детали** должны зависеть от **абстракций**.

#### Суть и примеры

* Вместо того чтобы класс высокого уровня (например, `BusinessLogic`) напрямую знал о классе низкого уровня (`SqlRepository`), мы используем **абстракцию** (интерфейс `IRepository`).
* **Класс верхнего уровня** (бизнес-логика) работает с `IRepository`.
* **Класс нижнего уровня** (конкретное хранилище — SQL, NoSQL, mock) реализует этот интерфейс.
* Таким образом, логика не «жёстко прикреплена» к конкретной детали, и мы можем подменять реализацию на другую, не ломая верхний слой.

#### Как применять

* Использовать **интерфейсы** или **абстрактные классы** в качестве «контрактов» между слоями.
* Применять **инверсию управления (IoC)**: внедрение зависимостей (Dependency Injection) при необходимости.
* Это позволяет легко тестировать верхний слой, подставляя «заглушки», и менять реализации без переписывания кода «сверху».

***

### Итог

Принципы **SOLID** помогают проектировать код по ООП так, чтобы он был:

1. **Устойчивым к изменениям** (OCP, DIP),
2. **Простым для расширения** (OCP, SRP, ISP),
3. **Несильно связанным** (LSP, DIP, ISP),
4. **Понятным и модульным** (SRP).

Применять их важно **в меру**: не нужно насильно разбивать всё на десяток интерфейсов «просто так», но если чувствуете, что код становится хрупким, неудобным или слишком связанным, — посмотрите, не нарушается ли какой-то из принципов SOLID, и поправьте архитектуру.
