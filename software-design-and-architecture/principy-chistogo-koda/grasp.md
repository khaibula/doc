# GRASP

**GRASP (General Responsibility Assignment Software Patterns)** — это набор принципов/паттернов, предложенных Крэйгом Ларманом (Craig Larman) для распределения обязанностей между объектами в объектно-ориентированных системах. GRASP помогает отвечать на вопрос «Какой объект должен делать то или иное?» и поддерживает баланс между связностью, когезией и чёткостью в архитектуре.

Ниже рассмотрим **девять** паттернов/принципов GRASP, их краткую суть и примеры.

***

### 1. Creator (Создатель)

**Идея**\
Определяет, **какой объект** должен отвечать за **создание** (инстанцирование) других объектов.

**Правило**\
Объект A должен создавать объект B, если:

1. A содержит или агрегирует объекты B.
2. A записывает объекты B в необходимые структуры.
3. A имеет необходимые данные для инициализации B.
4. Явно логично, что A является «владельцем» или «хранителем» B (в предметном смысле).

**Пример**\
В интернет-магазине класс `Order` может быть «создателем» `OrderItem`, поскольку `Order` агрегирует элементы заказа. Когда добавляем товар, `Order` создаёт `OrderItem` (ему известны все нужные данные).

***

### 2. Information Expert (Информационный эксперт)

**Идея**\
Метод должен быть реализован в **том классе**, который **обладает всей (или почти всей) необходимой информацией**, чтобы выполнить задачу.

**Правило**\
Спросите: «Какой объект знает всё нужное, чтобы выполнить этот метод без «выпрашивания» данных?» → именно он и есть «эксперт» для реализации.

**Пример**\
Метод `calculateTotal()` логично поместить в `Order`, потому что `Order` знает свой список `OrderItem`, их цены, количество — всё, чтобы подсчитать итог. Не надо передавать Order «снаружи» куда-то и там высчитывать.

***

### 3. Controller (Контроллер)

**Идея**\
Определяет, **какой объект** берёт на себя роль обработки «системных операций» (запросы от UI или внешних систем).

**Правило**

* Контроллер может быть «участником» предметной области, часто называемым «Session», «Facade» или «Controller».
* Он **принимает** запросы (например, «создать заказ») и координирует нужную логику, делегируя детали объектам-доменам (Expert).

**Пример**\
В слое архитектуры (MVC, MVVM) есть `OrderController`, который обрабатывает вызов `createOrder`, вызывает `OrderService` или создает `Order` и т.д. Контроллер не хранит бизнес-логику внутри себя, а лишь принимает запрос и делегирует.

***

### 4. Low Coupling (Низкая/Слабое зацепление)

**Идея**\
Стремимся, чтобы классы **как можно меньше зависели** друг от друга (минимальное число связей «кто-кем пользуется», «кто о ком знает»).

**Выгоды**

* Упрощение сопровождения: если один класс меняется, меньше риск ломать другие.
* Легче тестировать и переиспользовать.

**Пример**\
Вместо того чтобы класс «A» напрямую создавал `new B()`, мы можем внедрять B в A через интерфейс (DIP), чтобы A «не знал» деталей реализации B.

***

### 5. High Cohesion (Высокая связность)

**Идея**\
Объект (или модуль) должен **выполнять ограниченный, связанный набор обязанностей**, чтобы он **не был перегружен** и имел чёткую ответственность.

**Параллель**\
Похоже на SRP (Single Responsibility Principle). Высокая связанность означает, что всё в классе «сплочено» вокруг одной задачи.

**Пример**\
Класс `UserValidator` занимается только проверкой пользовательских данных (валидация), а не отвечает одновременно за доступ к БД или отправку писем.

***

### 6. Polymorphism (Полиморфизм)

**Идея**\
Когда есть несколько вариантов поведения (алгоритмов), мы используем **полиморфизм** (переопределение методов или реализация разных интерфейсов), а не громоздкие `if-else` или `switch-case` проверки типа.

**Пример**\
Вместо `if (shape.type === "circle") { ... } else if (shape.type === "square") { ... }`, делаем абстрактный класс/интерфейс `Shape` с методом `draw()`, и в `Circle`, `Square` переопределяем `draw()` по-своему. Код, использующий `Shape`, вызывает `shape.draw()`, не зная, круг это или квадрат.

***

### 7. Pure Fabrication (Чистая «выдумка»)

**Идея**\
Если у нас нет в предметной области очевидного «эксперта», который бы мог выполнить задачу, мы **создаём искусственный класс** (или сервис), чтобы сохранить **низкую связность** и **высокую когезию**.

**Пример**\
Пусть у нас есть задача «логировать действия пользователя». Логика не относится к какому-то конкретному доменному классу (User, Order и т.д.), но мы не хотим раздувать их ответственности. Тогда делаем «сервис логирования» (например, `AuditService`), это класс «чистая выдумка», не являющийся частью предметной области напрямую, но помогающий соблюдать принципы.

***

### 8. Indirection (Посредничество)

**Идея**\
Вставляем **промежуточный объект** (слой) между двумя другими, чтобы **слабее их связать** или реализовать какую-то дополнительную логику/политику взаимодействия.

**Пример**

* Взаимодействие между UI и БД не напрямую, а через «сервисный слой», чтобы UI не знал деталей SQL/ORM.
* Паттерн **Mediator**: объекты общаются через «посредника», снижая взаимозависимости.

***

### 9. Protected Variations (Защищённые вариации)

**Идея**\
Оберегаем части системы от изменений (или вариаций) в других её частях, устанавливая «стабильные интерфейсы», абстракции или анти-«протечки» деталей.

**Похоже**\
На «открыто/закрыто» (OCP) из SOLID: мы создаём **точки расширения**, чтобы изменения в одном месте не ломали другое.

**Пример**

* Используем «Adapter» или «Facade» для интеграции с внешним API. Если внешний API меняется, мы дорабатываем адаптер, **не** трогая всё приложение.
* Интерфейс `IRepository` не меняется, даже если мы сменим реальную БД (MySQL, Mongo) — код приложения защищён от вариаций СУБД.

***

### Итоговая сводка

* **Creator**: «Кто создаёт?»
* **Information Expert**: «Кому реализовать метод? Тому, кто владеет данными.»
* **Controller**: «Кто управляет системными операциями?»
* **Low Coupling**: «Минимизируем зависимость классов друг от друга.»
* **High Cohesion**: «Каждый класс выполняет связанную, узкую ответственность.»
* **Polymorphism**: «Пусть различия в поведении реализуются через полиморфизм, а не `if-else`.»
* **Pure Fabrication**: «Если нет естественного эксперта — создаём искусственный класс/сервис.»
* **Indirection**: «Вводим посредника, чтобы ослабить связь или добавить абстракцию.»
* **Protected Variations**: «Защищаемся от изменений, устанавливая интерфейсы/абстракции на границах вариаций.»

**GRASP** помогает при проектировании ООП-приложений, распределяя обязанности по классам так, чтобы достичь **пониженной связности, высокой когезии** и понятной архитектуры. Это прекрасное дополнение к принципам **SOLID** и паттернам **GoF** (Gang of Four).
