# Декомпозируй

**Keep it Small** (или декомпозиция логики на более мелкие, управляемые части) — это принцип, который тесно связан с идеями _чистого кода_ и _Single Responsibility Principle (SRP)_. Он означает, что мы стараемся разбивать большие куски функционала на более мелкие компоненты (функции, классы, модули), каждый из которых решает конкретную подзадачу. Ниже разберём, **почему** это важно, **когда** декомпозиция может быть избыточной и **как** можно это контролировать (в том числе программно).

***

### Зачем декомпозировать логику (Keep it Small)

1. **Упростить чтение и понимание**
   * Когда функция или класс делает чётко одну задачу, становится намного легче разобраться в коде.
   * Разработчику не нужно «скроллить» сотни строк, где намешаны разные уровни логики, он видит короткий метод «calculateTax» или «validateEmail», и сразу ясно, чем он занимается.
2. **Повышение переиспользуемости**
   * Мелкие функции или компоненты, решающие узкую задачу, легче переиспользовать в других местах.
   * Если один метод «валидиует» данные, другой — «форматирует», третий — «сохраняет», то их можно комбинировать в разных сценариях.
3. **Облегчение тестирования**
   * Мелкие функции проще покрывать юнит-тестами, так как у них ограниченное число сценариев и зависимостей.
   * Легко изолировать и проверить, правильно ли «работает конкретный кусочек».
4. **Упрощение сопровождения и расширения**
   * Если нужно изменить какую-то логику, мы идём в конкретный метод/класс, а не рыщем по длинной простыне кода.
   * Проще разобраться, где что находится, уменьшив риск поломать смежные части.
5. **Снижение когнитивной нагрузки**
   * Принцип «малых методов» (Small Functions) помогает программисту держать в голове только маленький объём логики.
   * По сути, это «разделяй и властвуй»: проблему проще решить, когда она разбита на мелкие подзадачи.

***

### Когда декомпозиция может быть избыточной

1. **Слишком мелкие методы без реального смысла**
   * Если вы заводите метод «getUserNameLength()», который просто `return user.name.length`, то это может выглядеть абсурдно — реальной пользы нет.
   * Постоянно разбивать логику «в одну строчку» может затруднить чтение, так как приходится прыгать между множеством методов.
2. **Избыточное дробление классов/файлов**
   * Создание десятков файлов, где в каждом по 2–3 строки кода, может мешать ориентироваться.
   * Порой логичнее сохранить 2–3 функции близко друг к другу, если они тесно связаны и не будут переиспользоваться по отдельности.
3. **Оверинжиниринг паттернами**
   * Иногда, пытаясь соблюдать «Keep it Small», разработчики бессознательно внедряют кучу абстракций (стратегии, фабрики и т.п.), хотя проблема решается двумя-тремя методами в одном классе.
   * Нужно учитывать реальный масштаб задачи: если система маленькая, а мы строим слишком сложную архитектуру, это затруднит поддержку.
4. **Противоречие бизнес-логике**
   * Бывают куски кода, которые должны «идти» единым блоком, отражая специфику предметной области. Слишком мелкая нарезка может «размыть» контекст и запутать смысл.

В итоге, как и везде, важно **чувство меры**. Мелкие куски – хорошо, но без фанатизма.

***

### Как контролировать уровень декомпозиции (и «слежение» за тем, чтобы код оставался «маленьким»)

#### 1. Статические анализаторы и линтеры

* **ESLint (JavaScript/TypeScript)** с плагинами. Существуют плагины, которые указывают на «слишком большие функции» (например, `max-lines-per-function`, `complexity` и т.д.):
  * `max-lines-per-function` можно настроить на 30–50 строк.
  * `complexity` может подсказать, что у вас «cyclomatic complexity = 20» и функция слишком ветвится.
* **SonarQube** или аналогичные инструменты (если у вас большой проект) могут измерять различные метрики (File size, Function complexity, etc.).

#### 2. Метрики комплексности (Cyclomatic Complexity, Cognitive Complexity)

* **Cyclomatic Complexity**: измеряет количество ветвлений (`if`, `switch`, `for`, `while`). Чем больше ветвлений, тем сложнее тестировать и понимать код.
* **Cognitive Complexity**: учитывает вклад вложенных конструкций. Когда метрика превышает порог (например, 15–20), стоит разбивать на подзадачи.

#### 3. Code review

* Простейший инструмент контроля – **взаимная проверка кода** (Code Review). Ревьюер может заметить «У тебя тут метод на 100 строк, давай разобьём». Или «Слушай, у тебя 10 маленьких файлов, каждый по 3 строчки, может, объединим?».

#### 4. Конвенции и гайды (заранее оговоренные)

* Можно прописать в Style Guide: «Методы не должны превышать 40–50 строк», «Cyclomatic Complexity > 10 – рефакторим», «В одном файле не более 300–400 строк кода» и т.п.
* Это не жёсткие правила, а скорее **ориентиры**, когда стоит задуматься о декомпозиции.

#### 5. Архитектурные паттерны (модули, сервисы)

* Если у вас принято разделять логику по «сервисам», «репозиториям», «контроллерам», «компонентам», сама архитектура подталкивает к естественному разделению.
* Иногда фреймворки (Angular, NestJS, React + Redux/Context) уже диктуют структуру, где много маленьких файлов.

***

### Итог

**Keep it Small** (декомпозировать логику) полезно, потому что:

* Упрощает **чтение** и **понимание** кода.
* Улучшает **переиспользуемость** и **тестируемость**.
* Позволяет избегать «громоздких» структур.

Но нельзя доводить до абсурда:

* **Очень** мелкие функции/classes/files могут ухудшить восприятие.
* Нужно «грамотно» выбирать уровень декомпозиции, учитывая **business-context** и **масштаб** проекта.

**Инструменты** для контроля:

1. **Линтеры и статические анализаторы**: `max-lines-per-function`, `complexity`, SonarQube, etc.
2. **Метрики** (Cyclomatic/Cognitive Complexity).
3. **Code review** и **чёткие Style Guides**.

Важнее всего — **здравый смысл**: если метод/класс стал чересчур большим или сложным, — делим на части. Если, наоборот, получилась сеть из 20 методов по 2–3 строки каждый — возможно, стоит объединить некоторые логически связанные куски.
