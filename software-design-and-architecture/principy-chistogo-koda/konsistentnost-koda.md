# Консистентность кода

**Консистентность кода** (code consistency) – это единообразие и согласованность во всех аспектах написания и организации кода. Когда мы говорим о «консистентном» коде, подразумеваем единый стиль (форматирование, именование), согласованное применение паттернов проектирования, согласованную структуру файлов и директорий и т.д.

Ниже разберём:

1. **Зачем нужна консистентность**
2. **Как поддерживать консистентность**
3. **Когда и как можно «осознанно» нарушить консистентность**

***

### 1. Зачем нужна консистентность

#### 1.1. Упрощение чтения и понимания

* Если код во всём проекте придерживается **одинаковых правил**, разработчику проще ориентироваться.
* При переключении между разными модулями или файлами нет ощущения «каждый пишет, как хочет».

#### 1.2. Снижение когнитивной нагрузки

* Условная «автоподсказка» у разработчика в голове: зная, как устроен один компонент, он быстро понимает структуру другого.
* Не приходится тратить время, чтобы угадать: «Как автор назвал здесь переменную?» или «В каком формате здесь написаны методы?».

#### 1.3. Уменьшение количества ошибок

* Когда стили и подходы одинаковы, меньше «случайных» несостыковок.
* При ревью кода, если всё оформлено единообразно, легче заметить реальные проблемы логики, а не тратить время на стилевые несоответствия.

#### 1.4. Ускорение онбординга новых разработчиков

* Новичкам проще влиться в проект, где есть чёткие конвенции, принципы организации кода и структуры файлов.
* Вместо «читай весь код и разбирайся, почему везде по-разному», человек берёт единый гайд и быстро адаптируется.

#### 1.5. Облегчение автоматизации

* Линтеры, форматтеры, статические анализаторы могут автоматически проверять и исправлять большой пласт правил, если в проекте приняты единые соглашения.

***

### 2. Как поддерживать консистентность

#### 2.1. Code Style (ESLint, Prettier и т. д.)

* **Автоматические инструменты**:
  * ESLint/TSLint (правила для стиля и возможных ошибок).
  * Prettier (форматирование).
* Настраивайте конфигурации этих инструментов под общие принципы команды: отступы, кавычки, точки с запятой, стили стрелочных функций, и т.д.

#### 2.2. Конвенции по именованию и структуре

* **Нейминг** (переменные, методы, классы): договориться, как именовать компоненты (PascalCase, camelCase), как называть методы (handleClick, onSubmit), как писать константы (ALL\_CAPS?), и т.д.
* **Соглашение по структуре приложения**:
  * Например, «каждый компонент в своей папке с отдельным файлом стилей», либо «все компоненты в одной папке /components, хуки – в /hooks».
  * Список «best practices» по оформлению импортов, где хранить типы и т.п.

#### 2.3. Единообразный подход к паттернам и архитектуре

* Если вы применяете React + Redux, договоритесь, как структурировать actions, reducers, selectors.
* Если используете Context API, договоритесь, как организовывать контексты (один общий или несколько узких).
* В Angular/React/Vue — договоритесь о том, как именовать директории, где хранить сервисы, где — типы, где — константы.

#### 2.4. Документация и Style Guide

* **Документируйте ключевые моменты**: например, короткий Markdown-файл «Code Style Guidelines» в репозитории.
* Если в проекте есть «wiki», укажите там «как правильно оформлять» компоненты, как заводить новые модули, и т. д.

#### 2.5. Code Review

* **Код-ревью** — важный механизм поддержания консистентности.
* Ревьюверы указывают на нарушения принятых конвенций: «Тут отступы не по Prettier», «здесь метод назван не по нашему соглашению».
* Правильно настроенный CI/CD может отклонять Pull Request, если линтер/протект-правила не проходят.

#### 2.6. Автоматизация рутин

* Запуск линтера/форматтера **автоматически** при коммите (например, Husky + lint-staged в Git).
* ESLint/Prettier могут автоматически исправлять мелкие огрехи (пробелы, точки с запятой) до того, как код попадёт в репозиторий.

***

### 3. Как «правильно» нарушать консистентность, если нужно

Случаются ситуации, когда «исключение» действительно оправдано и не вписывается в общие правила. Важно:

1. **Иметь вескую причину**
   * Техническую: «здесь нужно отступить от общей структуры, т. к. библиотека X требует особой конфигурации».
   * Понятную для всей команды: «данная функция в корне специфична и не должна следовать общему паттерну, иначе получим overengineering».
2. **Документировать исключение**
   *   Если вы ломаете формат (например, отключаете линтер на конкретную строку), оставьте **комментарий**:

       ```js
       // eslint-disable-next-line no-underscore-dangle
       // Причина: библиотека Y требует, чтобы поле называлось __someInternal
       someObject.__someInternal = ...
       ```
   * Если изменяете структуру папок, обязательно отразите это в README или wiki: «Модуль X лежит здесь по таким-то причинам».
3. **По возможности «изолировать» место нарушения**
   * Если у вас есть действительно уникальная логика, которая не вписывается в общий паттерн, постарайтесь ограничить это одной папкой или файлом, а не рассеивать специфические решения по всему проекту.
   * Если вам нужен специфический ESLint-правила override, настройте его **локально** (например, через `.eslintrc` в поддиректории), а не глобально.
4. **Переоценивать «исключения» со временем**
   * Бывает, что временное исключение устаревает.
   * Периодический рефакторинг и ревью кода могут выявить, что можно вернуться к обычным правилам, и «хак» больше не нужен.

***

#### Пример «осознанного» нарушения

Допустим, по корпоративному соглашению все приватные методы начинают с `_`. Но вы используете внешнюю библиотеку, которая **требует** назвать метод `__init__`. ESLint по умолчанию ругается, но вы оставляете:

```js
class SomeLibWrapper {
  // eslint-disable-next-line no-underscore-dangle
  __init__() {
    // ...
  }
}
```

* Обязательно: поясните в комментарии «Метод требуется библиотекой X, потому что ...».

Ещё пример:\
Если у вас принято, что каждый компонент React в отдельном файле, но вдруг вам нужно **микро-компонент**, который логически не стоит «раздувать» до отдельного файла. Вы решаете поместить его в один файл рядом с основным компонентом, прописывая комментарий в коде или PR, чтобы ревьюеры понимали, почему сделано исключение.

***

### Итог

* **Консистентность** в коде — мощный способ сделать проект понятным, упрощая онбординг и уменьшая количество ошибок.
* Добиться её можно **соглашениями** (Code Style Guides), **автоматическими инструментами** (ESLint, Prettier) и **код-ревью**.
* Если нужно отступить от правил, делайте это **осознанно** и **локально**, с чётким объяснением, почему так надо.

В результате вся команда выигрывает, поскольку код становится однородным, легко читаемым и предсказуемым – что повышает продуктивность и качество разработки.
