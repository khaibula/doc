# Принципы чистого кода

«Чистый код» — это код, который легко читать, понимать, поддерживать и развивать.

### 1. Говорящие названия (Meaningful Names)

1. **Переменные, функции, классы** должны иметь названия, которые чётко отражают их назначение.
2. **Избегать сокращений** (особенно непонятных), если только это не общеупотребительные аббревиатуры (например, `HTML`, `HTTP` и т. д.).
3. **Называть методы по действиям** (например, `calculateTotal`, `sendEmail`), чтобы сразу было понятно, что происходит.
4. **Называть классы/объекты существительными** (например, `Order`, `User`, `Invoice`).
5. **Одно понятие — одно слово** (если у вас есть методы `fetchUser()`, `retrieveUser()`, `getUser()`, лучше выбрать что-то одно, чтобы не путать разработчиков).

***

### 2. Малые функции (Small Functions)

1. **Функция должна делать что-то одно** и делать это хорошо. Если она начинает расти до десятков строк с несколькими ветвлениями, вероятно, надо сделать рефакторинг.
2. **Один уровень абстракции**: внутри одной функции не смешиваем «высокоуровневую» логику (например, общий алгоритм) и «низкоуровневые» детали (например, конкретные проверки или форматирование). Разделяем их по разным методам.
3. **Минимизируем количество параметров** (Long Parameter List — это «запах»). Часто лучше передать объект или разделить логику на несколько методов.

***

### 3. Единая ответственность (SRP – Single Responsibility Principle)

1. **Каждый модуль/класс** должен иметь **единственную причину для изменения**.
2. Это упрощает понимание, тестирование и доработку. Если в одном классе «намешано» несколько ролей (например, и доступ к данным, и отрисовка, и бизнес-логика), его сложнее поддерживать.

***

### 4. DRY (Don’t Repeat Yourself)

1. **Избегайте дублирования кода**. Если алгоритм или формула повторяется в нескольких местах, вынесите её в отдельный метод/класс.
2. Дублирование усложняет поддержку: при изменении логики надо искать все копии и править их вручную.
3. Иногда есть допустимое «минимальное» дублирование для читабельности, но крупные блоки кода лучше выносить в «единый источник правды».

***

### 5. KISS (Keep It Simple, Stupid)

1. **Не усложняйте решение**, когда можно сделать проще.
2. Избыточные абстракции, сложные шаблоны, «универсальные» механизмы на будущее только мешают понимать код (см. Speculative Generality).
3. Сначала делаем рабочий и понятный вариант, а затем, при необходимости, совершенствуем.

***

### 6. YAGNI (You Ain’t Gonna Need It)

1. **Не пишите функциональность «на всякий случай»**, если она не требуется прямо сейчас.
2. Предвосхищение (спекулятивное добавление фич, абстракций) приводит к ненужной сложности и затратам на поддержку.
3. Когда потребность действительно возникнет, вы рефакторите/добавляете новую функциональность осмысленно.

***

### 7. Правильная организация кода и модулей

1. **Связанная логика должна быть рядом**: функции и классы, которые вместе решают одну задачу, лучше держать в одном модуле/пакете.
2. **Не смешивать разные уровни логики**: например, слой доступа к данным (DAO, репозитории) не должен знать детали UI, а слой UI не должен «говорить напрямую» с SQL-запросами.

***

### 8. Избегать избыточных комментариев

1. Если приходится писать много комментариев, объясняющих «что делает этот кусок кода» — возможно, код слишком сложен и требует рефакторинга.
2. Комментарии должны дополнять код (например, описывать нетривиальные алгоритмы, документировать публичные интерфейсы), а не оправдывать его сложность.
3. Код должен быть **самодокументируемым**: за счёт чётких названий методов, классов, переменных.

***

### 9. Управление исключениями (Exceptions) и обработкой ошибок

1. **Не прятать ошибки** (пустые блоки `catch`), лучше явно логировать или пробрасывать выше, чтобы было понятно, что произошло.
2. **Не использовать исключения для обычного управления потоком** (это порождает путаницу и просадки в производительности).
3. **Проверять граничные условия** (валидация входных данных, предусловия, постусловия) — лучше предотвратить ошибку, чем обрабатывать последствия.

***

### 10. SOLID (как часть хорошего ООП-дизайна)

1. **Single Responsibility Principle** (SRP) — обсуждали выше: один класс — одна ответственность.
2. **Open/Closed Principle** (OCP) — классы и модули открыты для расширения, но закрыты для модификации (при добавлении фич стараемся не править уже стабильный код, а расширять через интерфейсы/наследование).
3. **Liskov Substitution Principle** (LSP) — наследники должны корректно подменять родителей без нарушения логики.
4. **Interface Segregation Principle** (ISP) — лучше несколько специализированных интерфейсов, чем один «жирный».
5. **Dependency Inversion Principle** (DIP) — модули верхнего уровня не зависят от конкретных реализаций нижнего уровня; оба зависят от абстракций.

***

### 11. Тестируемость и покрытие тестами

1. **Писать код так**, чтобы его было просто тестировать (малые функции, минимальная связность, чёткие входы/выходы).
2. **Чем легче код тестируется**, тем скорее вы найдёте проблемы при изменениях.
3. Модули с «чистой» архитектурой естественным образом проще покрывать тестами.

***

### 12. «Boy Scout Rule» (Правило скаута)

1. Всегда старайтесь оставить код **чуть лучше**, чем он был.
2. Даже если правите небольшую вещь, вы можете подправить соседние «мелкие» проблемы (названия переменных, форматирование, убрать дублирование).
3. Это помогает поддерживать код в хорошем состоянии в долгосрочной перспективе.
