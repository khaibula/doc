# Голливудский принцип

**Hollywood Principle** («Принцип Голливуда») часто формулируется фразой

> _"Don’t call us, we’ll call you."_ (Не звоните нам, мы сами вам позвоним).

В контексте разработки ПО этот принцип подразумевает, что высокоуровневый код (например, фреймворк) **берёт на себя** контроль над потоком выполнения, а вы (ваш «пользовательский» код или «низкоуровневый» модуль) **только предоставляете «точки входа»** (hooks, колбэки, инверсии управления), которые фреймворк вызывает в нужный момент.

Таким образом, **инициатива** и **управление потоком** сосредоточены в фреймворке (или ядре системы), а ваш код «призовётся» (will be called) при необходимости.

***

### Зачем нужен Hollywood Principle

1. **Инверсия управления (IoC)**
   * Принцип Голливуда — неотъемлемая часть **Inversion of Control**. Вместо того чтобы ваш код создавал и дергал фреймворк, сам фреймворк вызывает ваши компоненты.
   * Это упрощает структуру: вам не нужно вручную orchestrate (управлять) всеми вызовами и создание объектов; фреймворк сам знает, когда что исполнить.
2. **Расширяемость без ломки**
   * Фреймворки предоставляют «плагины» (или «hookи»). Вы только реализуете интерфейсы или колбэки. Фреймворк позаботится о последовательности вызовов.
   * При добавлении новых компонентов или меняющихся условий, не нужно переписывать главный поток: фреймворк остаётся прежним, а вы подкладываете новый «кусочек» логики, который фреймворк вызовет.
3. **Упрощение тестирования**
   * Компоненты с колбэками можно тестировать в изоляции. Фреймворк при тестах либо мокается, либо поднимается в тестовом окружении.
   * Код компонентов не зависит от глобальной структуры, он просто ждет «вызова» (callback) с нужными данными.
4. **Сокращение дублирования**
   * Основной «поток жизни» (lifecycle) реализован в одном месте — в фреймворке. Ваш код «подписывается» на нужные этапы (например, `onInit`, `onDestroy`, `beforeRouteEnter` и т.д.), не копируя логику запуска приложения.

***

### Пример в практическом ключе

#### Пример: React (JS/TS)

* React управляет рендерингом компонентов. Мы **не** вызываем «отрендери компонент MyComponent». Мы лишь **объявляем** компонент (функцию или класс) и отдаем React’у через `<MyComponent />`.
* React сам решает, когда вызвать `function MyComponent()`, когда обновлять (с вызовом `useEffect()`).
* Фраза «Don’t call us, we’ll call you» заметна: мы **не** дергаем напрямую `render()`, это делает сам React при изменении стейта или пропсов.

#### Пример: Angular

* У нас есть классы компонентов, наследующиеся от Angular «Component». Мы **не** вызываем напрямую методы `ngOnInit()` / `ngOnDestroy()`. Angular-фреймворк делает это сам в нужный момент жизненного цикла.
* Мы описываем поведение (что делать в `ngOnInit`), но не вызываем этот метод напрямую.

#### Пример: IoC-контейнеры (NestJS, Spring)

* Мы декларируем классы-сервисы (например, `@Injectable()` в NestJS), и **контейнер** IoC решает, когда их создавать, куда внедрять (`constructor(private userService: UserService)`), и когда вызывать методы.
* Мы **не** управляем вручную, какая зависимость где создается — «фреймворк» (или «контейнер») «вызывает» нас, а не наоборот.

***

### Связь с DIP и Inversion of Control

* **Hollywood Principle** — практическое выражение IoC и **Dependency Injection**.
* Говорит: «Вы предоставляете **интерфейсы** и **реализации**, а фреймворк (или верхнеуровневый модуль) сам решает, когда и как их использовать.»

***

### Итог

**Hollywood Principle** («Don’t call us, we’ll call you») означает, что ваш код следует «правилам игры» фреймворка (или ядра системы), предоставляя нужные **точки входа** (колбэки, хуки, сервисы) и **реализации интерфейсов**, а сам фреймворк вызывает это в нужный момент. Такой подход облегчает масштабирование, повторное использование и тестирование, ведь основной контроль за потоком исполнения сосредоточен в одном месте, а расширения (ваш код) подключаются по мере необходимости.
