# Композиция важнее наследования

В объектно-ориентированном проектировании принцип **Composition over Inheritance** призывает предпочитать **композицию** (составление объектов из более мелких) вместо **наследования** (классического механизма «класс-потомок»).

Суть в том, что при композиции вы **вкладываете** объект (или ссылку на него) внутрь другого объекта, а не наследуете поведение родителя. В результате вы получаете **более слабую связанность** и гибкость, поскольку можно менять поведение динамически, добавлять или убирать компоненты без ломки всей иерархии.

***

### 1. Почему «композиция» лучше наследования

1. **Ослабление связности**
   * Наследование жёстко связывает подкласс с родителем: изменение в родителе может поломать всех наследников.
   * При композиции объект может свободно заменять или конфигурировать свои компоненты, не меняя свой «тип».
2. **Гибкость расширения**
   * Легко добавлять новый функционал: вы создаёте новый класс, реализующий нужное поведение, и «вкладываете» его в объект.
   * При наследовании вы бы вынуждены расширять иерархию, наращивая «ветвь» наследников.
3. **Возможность менять поведение «на лету»**
   * При композиции можно в рантайме подменять вложенный объект (паттерны Strategy, State).
   * Наследование, напротив, фиксирует класс (и поведение) при компиляции.
4. **Избегание проблем с множеством родителей**
   * Множественное наследование (в языках, где оно разрешено, например C++) усложняет дизайн.
   * В языках как Java/TypeScript/JavaScript, где только одиночное наследование, вы не можете наследовать от двух классов. Композиция легко решает эту задачу, «собирая» класс из нескольких компонентов.
5. **Соответствие принципам SOLID**
   * Особенно LSP (Liskov Substitution Principle): иногда «подкласс» нарушает логику родителя. Композиция позволяет вам гибче выбирать, как вести себя, не ломая контракт.
   * DIP (Dependency Inversion Principle): мы зависим от абстракций (компонентов), а не от конкретного родителя.

***

### 2. Пример (как применять на практике)

Допустим, у нас есть сущность «Duck» (утка), которая умеет **летать** и **квакать**. В классическом подходе (наследование) мы бы сделали `Duck -> MallardDuck, RubberDuck`, и т.д. Но, при расширении, если появятся десятки видов уток, всё может стать громоздко.

#### 2.1 Наследование (как не надо, когда становится слишком жёстко)

```typescript
class Duck {
  public quack(): void {
    console.log("Кря-кря!");
  }
  public fly(): void {
    console.log("Утка летит!");
  }
}

class RubberDuck extends Duck {
  // У резиновой утки fly() не нужен, переопределяем или бросаем ошибку
  public fly(): void {
    console.log("Резиновая утка не летает!");
  }
  
  // quack() тоже может быть иной (пищалка?), 
  // но придётся override.
  public quack(): void {
    console.log("Пищим, а не крякаем.");
  }
}

// Если появляется новый тип утки (WoodenDuck), 
// снова надо переопределять методы...
```

* Мы видим, что `RubberDuck` вынуждена «отвергать» (override) часть родительского поведения. Это «Refused Bequest» (антипаттерн).

#### 2.2 Композиция (лучше)

Вместо больших иерархий мы берём **две** стратегии (или компоненты): `FlyBehavior`, `QuackBehavior`.

* Любая утка содержит ссылки на объекты (или классы) – «умеет ли она летать», «как она крякает».
* Это называется паттерн **Strategy**.

```typescript
// Интерфейсы поведения
interface FlyBehavior {
  fly(): void;
}
interface QuackBehavior {
  quack(): void;
}

// Конкретные реализации
class FlyWithWings implements FlyBehavior {
  public fly() {
    console.log("Лечу, взмахивая крыльями!");
  }
}
class FlyNoWay implements FlyBehavior {
  public fly() {
    console.log("Не могу летать :(");
  }
}

class QuackNormal implements QuackBehavior {
  public quack() {
    console.log("Кря-кря!");
  }
}
class QuackSqueak implements QuackBehavior {
  public quack() {
    console.log("Пи-пи! (как резинка)");
  }
}

// Класс Duck, который вместо наследования 
// композируется из нужных стратегий
class Duck {
  private flyBehavior: FlyBehavior;
  private quackBehavior: QuackBehavior;

  constructor(flyBehavior: FlyBehavior, quackBehavior: QuackBehavior) {
    this.flyBehavior = flyBehavior;
    this.quackBehavior = quackBehavior;
  }

  public performFly(): void {
    this.flyBehavior.fly();
  }

  public performQuack(): void {
    this.quackBehavior.quack();
  }

  // Если надо, можно менять поведение на лету
  public setFlyBehavior(fb: FlyBehavior): void {
    this.flyBehavior = fb;
  }
  public setQuackBehavior(qb: QuackBehavior): void {
    this.quackBehavior = qb;
  }
}
```

```typescript
// Использование
function main() {
  // Обычная утка
  const mallard = new Duck(new FlyWithWings(), new QuackNormal());
  mallard.performFly();    // "Лечу, взмахивая крыльями!"
  mallard.performQuack();  // "Кря-кря!"

  // Резиновая утка
  const rubber = new Duck(new FlyNoWay(), new QuackSqueak());
  rubber.performFly();     // "Не могу летать :("
  rubber.performQuack();   // "Пи-пи! (как резинка)"

  // Можем динамически менять поведение
  rubber.setFlyBehavior(new FlyWithWings());
  rubber.performFly();     // "Лечу, взмахивая крыльями!"
}

main();
```

* Видим, что **композиция** (уточка содержит ссылки на объекты «как летать», «как квакать») позволяет гибко собирать новые «типы» уток без объявления новых наследников.
* Если завтра нужен `WoodenDuck`, достаточно сконфигурировать `Duck` с `FlyNoWay()` и, скажем, «без звука» или «скрипящий звук».

***

### 3. Когда наследование всё же лучше, чем композиция

Несмотря на рекомендации, **бывают случаи**, когда наследование более уместно:

1. **Реальная «is-a» семантика**
   * Если одно означает точно «является разновидностью» другого, и никакого конфликта в поведении нет, наследование бывает естественным. Например, в UI-фреймворках: `Button` наследуется от `UIComponent`.
2. **Шаблонный метод**
   * Если у вас есть базовый класс с «шаблонным методом» (Template Method), и подклассы должны переопределять часть шагов. Тогда наследование подходит.
3. **Библиотека/фреймворк заставляет**
   * Во многих фреймворках UI (React «extends React.Component», Angular «extends OnInit» в старом коде, и т.д.) мы обязаны наследовать, чтобы подключить фреймворк. Это не всегда «плохо» — это часть механизма фреймворка.
4. **Простые случаи, когда нет угрозы «Refused Bequest»**
   * Если базовый класс действительно общий, а наследник логически обогащает функциональность, и нет риска, что придется «выкидывать» или ломать методы родителя.

**Важно**:

* Наследование желательно только когда **логически** объект «является» более конкретной версией другого (Student → Person, Car → Vehicle).
* При малейших признаках, что часть поведения родителя не подходит («Refused Bequest», «вынужденный override»), лучше перейти к композиции.

***

### Итог

* **Composition over Inheritance** помогает делать код гибче и проще расширять. Выбрав композицию, вы убираете «жёсткую связность» и можете заменять / комбинировать поведение объектов.
* На практике это означает использовать паттерны вроде **Strategy**, **Decorator**, **State**, **Adapter** — все они основаны на том, что объект **вкладывает** другое поведение, а не наследуется.
* Наследование по-прежнему уместно, если это реально соответствует «is-a»-отношению без конфликтов, либо когда этого требует фреймворк.

Однако в большинстве случаев, при **добавлении новых возможностей** и гибкости, композиция оказывается надёжнее, чем раздувание иерархии наследования.
