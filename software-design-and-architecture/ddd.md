# DDD

**Domain-Driven Design (DDD)** — это подход к проектированию программного обеспечения, в котором главный акцент делается на глубоком понимании бизнес-домена (предметной области) и на **совместной** работе программистов и экспертов предметной области для создания модели, максимально соответствующей реальности. Эрик Эванс (Eric Evans) популяризировал DDD в своей книге «Domain-Driven Design: Tackling Complexity in the Heart of Software».

Ниже основные идеи и принципы DDD:

***

### 1. Ubiquitous Language (Единый язык)

* **Суть**: Все участники проекта (разработчики, аналитики, эксперты-доменщики) должны говорить на **едином языке**, отражающем понятия предметной области.
* **Почему это важно**: Избежать «пробелов» и недопонимания между бизнесом и разработчиками. Вместо технических жаргонов и двусмысленных терминов используется общий «словарь» реальных бизнес-терминов.
* **Практика**: Постоянно уточнять термины с экспертами, отражать их в коде (имена классов, методов, модулей) — чтобы код буквально «читал» предметную область.

***

### 2. Bounded Context (Ограниченный контекст)

* **Суть**: Разбивать систему на **контексты**, внутри которых «единый язык» чётко определён. В разных контекстах те же слова могут иметь разные значения.
* **Зачем**: В реальном бизнесе разные отделы и поддомены используют одинаковые термины с нюансами или разные термины для схожих вещей. «Bounded Context» гарантирует, что в каждом модуле/подсистеме термины однозначны, а связь между контекстами оговаривается явно.
* **Пример**: «Заказ» (Order) в контексте «Склад» (Warehouse) и «Биллинг» (Billing) может отличаться по атрибутам, по стадиям и т. д. Разумно развести в два bounded context'а (WarehouseContext и BillingContext), чтобы не путать.

***

### 3. Модель домена (Domain Model)

* **Суть**: Это **сердце** DDD — объектная (или функциональная) модель, отражающая бизнес-правила и структуру предметной области.
* **Задача**: В коде хранить не «таблицы БД» или «DTO» для UI, а именно **модель** сущностей, способных выражать логику и инварианты.
* **Советы**: Вместо анемичных объектов (только поля) — доменные объекты, у которых есть поведение (методы), соответствующее бизнес-сущностям.

***

### 4. Building Blocks (Блоки построения)

В DDD описано несколько **шаблонов**, как структурировать доменные объекты:

1. **Entity (Сущность)**
   * Объект, имеющий **идентификатор** и жизненный цикл. Главное в сущности — её идентичность, а не свойства.
   * Пример: `Order`, `User`.
2. **Value Object (Объект-значение)**
   * Объект, не имеющий собственной идентичности, характеризуется значением. Иммутабелен.
   * Пример: `Money`, `DateRange`, `Address`. Если два адреса имеют те же поля, они равны.
3. **Aggregate (Агрегат)**
   * Группа связанных сущностей и объектов-значений с одним корневым объектом (Aggregate Root).
   * Агрегат гарантирует **инварианты**: внешнему миру «виден» только корень (через репозиторий или сервис), а детали внутри агрегата меняются согласованно.
   * Пример: `Order` (корень), в нём коллекция `OrderItem` (дочерние сущности) — обновления списков должны соблюдать бизнес-правила.
4. **Domain Service**
   * Если логика не укладывается ни в сущность, ни в Value Object, но всё же относится к домену, выносим её в «сервис» (обычно stateless).
   * Пример: пересечение «двух расписаний», которое не привязано к конкретной сущности.
5. **Repository (Репозиторий)**
   * Абстракция доступа к агрегатам (сущностям) из хранилища (БД и т. д.). «Коллекция в памяти», дающая методы «findById», «save».
   * Прячет инфраструктурные детали (SQL, ORM) за доменным интерфейсом.
6. **Factory (Фабрика)**
   * Создание сложных агрегатов/объектов может быть централизовано в фабриках, чтобы конструировать правильное (валидное) состояние.

***

### 5. Domain Events (События домена)

* **Суть**: Когда в домене происходит что-то значимое («Заказ оплачен», «Товар добавлен в корзину»), порождается событие.
* **Зачем**:
  * Декларативно фиксировать «факт» в бизнес-логике.
  * Позволять другим частям системы реагировать, не связываясь напрямую (pub-sub, CQRS, реактивные сценарии).

***

### 6. Слои приложения (Layered Architecture в DDD-стиле)

Часто в DDD рекомендуют **многослойность** (похоже на классическое разделение, но чуть иначе):

1. **Application Layer**: координирует сценарии/кейсы, вызывает доменные объекты, не содержит бизнес-логики.
2. **Domain Layer**: сама модель (entity, value, domain service, repository-интерфейсы), тут суть бизнеса.
3. **Infrastructure Layer**: конкретные реализации репозиториев, интеграции, email-рассылок. Домен «не знает» технические детали.

***

### 7. Strategic Design (Стратегическое моделирование)

DDD предлагает методы **стратегического** анализа всей системы:

* **Context Map**: как связаны bounded context’ы (следующие паттерны: «partnership», «shared kernel», «anticorruption layer», «conformist», и др.).
* **Поддомены**: выделяем **core domain** (главная ценность, сложная бизнес-логика) и вспомогательные (supporting, generic). Главное внимание (и ресурсы) на core domain.

***

### Почему DDD?

1. **Главное — бизнес-логика**: Структура кода строится вокруг предметной области, а не вокруг БД или UI.
2. **Снижение «разрыва»** между IT и бизнесом: Единый язык, глубокое «вгрызание» в суть.
3. **Гибкость изменений**: Хорошо выстроенная модель позволяет легче менять/добавлять правила, не ломая всё подряд.
4. **Сложный бизнес-домен**: DDD особенно полезен, когда проект действительно сложный. В простых системах «подход» может быть избыточным.

***

### «Не серебряная пуля»

* DDD уместен там, где есть действительно **сложная** логика и **требуется** активная работа с экспертами.
* Если же проект простой (только CRUD), тяжёлые элементы DDD могут быть «overengineering».
* Важно «работать» над **Ubiquitous Language** и **bounded contexts**: без этого применение паттернов (Entity, Repository) не будет «настоящим» DDD.

***

#### Вывод

**Domain-Driven Design** — целостный набор подходов к сложным бизнес-системам:

* Собираем **единый язык** с экспертами,
* Делим систему на **bounded contexts**,
* Внутри **доменной модели** выделяем сущности, объекты-значения, агрегаты, события.
* Структурируем код так, чтобы «модель» отражала реальную предметную область.

Это делает систему более понятной и адаптируемой к изменениям бизнес-правил, но требует времени и совместной работы с domain experts для достижения глубокой модели.
