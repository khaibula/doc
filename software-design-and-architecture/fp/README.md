---
hidden: true
---

# ФП

**Функциональное программирование (FP)** — парадигма, в которой вычисления трактуются как вычисление **математических функций**, а преобразования данных — как применение этих функций без побочных эффектов. В отличие от **ООП**, где мы оперируем объектами, состоянием и методами, во **функциональном подходе** акцент ставится на **неизменяемость данных**, чистые функции и композицию.

Ниже — основные принципы функционального программирования, а также ключевые отличия от ООП.

***

### 1. Основные принципы функционального программирования

#### 1.1. Чистые функции (Pure Functions)

* **Чистая функция** не имеет **побочных эффектов** (side effects) и всегда возвращает один и тот же результат при одинаковых входных данных.
*   Пример (JavaScript/TypeScript):

    ```js
    function add(a, b) {
      return a + b; // не меняет внешние переменные, просто возвращает сумму
    }
    ```
* В отличие от «нечистых» функций, где может быть чтение/запись глобального состояния, вывод в консоль, сетевые запросы и т.д.

#### 1.2. Неизменяемость (Immutability)

* Данные не меняются «на месте». Вместо этого, при «изменениях» создаются новые структуры.
* В «чистом» функциональном языке (Haskell, например) все структуры данных по умолчанию неизменяемы.
*   Пример (JavaScript/TypeScript):

    ```js
    const arr = [1, 2, 3];
    // Вместо arr.push(4), создаём новый массив:
    const newArr = [...arr, 4];
    ```
* Уменьшает риски «случайного» изменения данных и упрощает отладку.

#### 1.3. Функции — «граждане первого класса» (First-Class Citizens)

* Функции могут передаваться как аргументы, возвращаться из других функций, храниться в структурах данных.
* Это позволяет строить мощные абстракции (map, reduce, filter, композиция функций, т. д.).

#### 1.4. Функциональная композиция (Function Composition)

* Композиция функций — объединение нескольких функций в одну более сложную, где выход одной функции становится входом другой.
*   Пример (JavaScript/TypeScript «псевдо»):

    ```js
    const toUpperCase = (s) => s.toUpperCase();
    const exclaim = (s) => s + "!";

    // Комбинируем:
    const shout = (s) => exclaim(toUpperCase(s));
    console.log(shout("hello")); // "HELLO!"
    ```

#### 1.5. Отсутствие/минимизация побочных эффектов (Side Effects)

* Побочный эффект — любое взаимодействие с внешним миром (I/O, изменение переменных, работу с файловой системой).
* FP-стиль старается локализовать такие эффекты или переносить их на «края» приложения (например, чтение ввода, вывод в консоль).
* В «чистом» функциональном языке вроде Haskell побочные эффекты обрабатываются через механизмы вроде «монады IO».

#### 1.6. Рекурсия вместо циклов (в некоторых языках)

* В классических функциональных языках (Haskell, Scheme) часто вместо `for` / `while` используют рекурсию.
* Многие функциональные языки оптимизируют хвостовую рекурсию (tail recursion) для эффективной работы.

#### 1.7. Применение «высших функций» (Higher-Order Functions)

* Функция, которая принимает другие функции как аргументы или возвращает функцию как результат, называется высшей.
* Пример: `Array.map(fn)`, `Array.filter(fn)` в JavaScript — классические высшие функции.

***

### 2. Отличия от ООП

#### 2.1. Работа с состоянием

* **ООП**: объекты имеют внутреннее состояние, которое может меняться методами.
* **FP**: состояние стараются держать неизменным (immutable). Вместо изменения состояния создают новые объекты/значения.

#### 2.2. Подход к структуре программы

* **ООП**: акцент на **классах**, **объектах**, наследовании, полиморфизме в терминах методов. Код организуют вокруг сущностей (User, Order) и их поведения (методы).
* **FP**: акцент на **функциях**, их композиции. Код организуют вокруг набора преобразующих функций, а данные — простые структуры без методов (или с минимумом).

#### 2.3. Моделирование vs. вычисление

* **ООП**: часто стремимся моделировать реальный мир, «У нас есть класс Car, у него метод drive()» — «машина» с состоянием.
* **FP**: часто рассматриваем задачи как **вычислительные** (трансформация входа в выход). Сферы вроде big data, «чистых» вычислений, параллельных операций часто удобнее описывать функционально.

#### 2.4. Наследование vs. композиция функций

* **ООП**: поощряет наследование (хотя мы часто говорим «композиция важнее наследования»). Есть полиморфизм, виртуальные методы.
* **FP**: наследования как такового нет (за редким исключением в мультипарадигм. языках), вместо этого есть композиция функций.

#### 2.5. Параллелизм

* **ООП**: наличие общего мутабельного состояния усложняет параллельное программирование (блокировки, гонки).
* **FP**: неизменяемость упрощает распараллеливание — нет риска конфликтов при записи.

***

### 3. Языки и подходы

* Чисто функциональные: **Haskell**, **PureScript**, **Elm**, **F#** (близко).
* Мультипарадигм.: **Scala**, **JavaScript/TypeScript**, **Python**, **C#**, **Ruby**, где можно писать в функциональном стиле (map, filter, reduce, лямбды), хотя язык поддерживает и ООП.
* Java 8+ частично ввёл функциональные элементы (лямбды, Stream API).

***

### 4. Пример на JavaScript (мультипарадигм, но функциональный стиль)

```js
// Список товаров
const products = [
  { name: "Laptop", price: 1500 },
  { name: "Mouse", price: 25 },
  { name: "Keyboard", price: 40 },
  { name: "Monitor", price: 300 }
];

// Чистая функция, которая применяет скидку
function applyDiscount(product, discount) {
  // Не мутируем исходный product
  return { ...product, price: product.price * (1 - discount) };
}

// Переходим к функциональному pipeline
const discounted = products
  .filter(p => p.price > 100)         // фильтруем дорогие
  .map(p => applyDiscount(p, 0.1))    // 10% скидка
  .map(p => p.name + ": $" + p.price);

// Вывод результатов
console.log(discounted);
// [ 'Laptop: $1350', 'Monitor: $270' ]
```

* **filter** / **map** — высшие функции.
* **applyDiscount** — чистая функция без побочных эффектов.
* Данные (`products`) неизменны; при скидке возвращается новый объект.

***

### 5. Где FP особенно удобно

1. **Работа с данными, трансформации** (ETL, big data, MapReduce).
2. **Высококонкурентные** или **параллельные** приложения, где неизменяемость упрощает код.
3. **Логика без сильной объектной модельной необходимости**: а именно, когда важны цепочки вычислений, вычислительные конвейеры (pipelines).
4. **Реактивные** или **функционально-реактивные** системы (RxJS, например), где поток данных обрабатывается функциями.

***

### Итог

* **Функциональное программирование** фокусируется на **чистых функциях**, неизменяемых данных, композиции и минимизации побочных эффектов.
* **ООП** строится вокруг объектов с внутренним состоянием и методами. FP старается избегать общего изменяемого состояния, делает акцент на функции и трансформации.
* В современных языках (JS/TS, Python, C#, Scala) часто сочетают эти парадигмы, применяя «лучшее из обоих миров» в зависимости от задач.
