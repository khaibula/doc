# Держись от фрейворков и библиотек подальше

**Keep Framework/Library Code Distant** – это принцип, призывающий держать код, зависящий от конкретных фреймворков или библиотек, **как можно дальше** от «сердцевины» (core) вашего приложения. Иными словами, не смешивать бизнес-логику (доменную логику) со специфическими вызовами или объектами из сторонних библиотек. Это позволяет:

1. **Предотвратить сильную связанность** с фреймворком
2. **Упростить тестирование** и рефакторинг
3. **Сделать код более универсальным** (легче перейти на другой фреймворк, обновить библиотеку или использовать часть логики в ином окружении)

Далее разберём, **почему** это важно, **как** придерживаться принципа и **примеры** его применения.

***

### 1. Почему важно «держать фреймворк на дистанции»

#### 1.1. Лёгкая смена технологий

* Если ваша логика вплетена повсюду во фреймворк (React, Angular, Nest, Spring и т.д.), переключение на другой инструмент потребует массового переписывания.
* Если же основная логика хранится в «чистой» части приложения, а взаимодействие с фреймворком сгруппировано в отдельных адаптерах, вы можете заменить или обновить фреймворк с минимальным ломом кода.

#### 1.2. Тестируемость

* Локализация зависимостей от внешней библиотеки позволяет **юнит-тестировать** бизнес-логику в изоляции (без запуска целого фреймворка).
* Меньше «магии» и меньше заглушек (mock) — тесты проще писать и поддерживать.

#### 1.3. Ясность архитектуры

* Код «внутри» доменной логики не обрастает фреймворк-специфичными понятиями (React-хуки, Angular-сервисы, ORM-энотии и т.п.).
* Чёткое разделение «вот тут у нас чистая логика» и «вот тут мы стыкуемся с библиотекой/фреймворком» делает структуру приложения более прозрачной.

#### 1.4. Гибкость переиспользования

* Если бизнес-логика реализована без завязки на конкретные инструменты, её можно повторно использовать в других проектах (например, в CLI-утилите или серверном скрипте), не таща за собой зависимости от UI-фреймворка.

***

### 2. Как придерживаться принципа

#### 2.1. Слои или архитектурные «кольца»

Идея взята из **Hexagonal Architecture**, **Чистой Архитектуры** (Clean Architecture) или **Onion Architecture**.

* В центре – **доменная логика** (чистые классы/функции, не зависящие от внешних пакетов).
* Снаружи – **адаптеры** (или «порты»), которые взаимодействуют с внешними источниками (UI, БД, сети).
* Любой вызов или данные от фреймворка (HTTP-запрос, React event) проходят через «слой адаптера», чтобы «переформатировать» их в более абстрактную форму для доменной логики.

#### 2.2. Отделение «core» кода и «infrastructure»

* **Core**: модули/классы, содержащие бизнес-логику (например, `calculateInvoiceTotal`, `validateOrder`, `UserService`). Это «чистый» код без импорта фреймворка.
* **Infrastructure** (или **Framework** слой): классы, которые знают о конкретном фреймворке (React-контроллеры, Angular-сервисы, Nest-контроллеры, ORM-репозитории).
* При необходимости Core-логика вызывается **через** интерфейсы/абстракции, чтобы Core не зависел от деталей реализации.

#### 2.3. Адаптеры и фасады

Если вам нужно сделать HTTP-запрос (в React) или запрос в БД (в NestJS), используйте «адаптер»:

* _Пример_: «UserRepository» — это интерфейс, который определяет методы (получить пользователя, сохранить). Внутри приложения мы работаем с этим интерфейсом, не заботясь, что там «TypeORM» или «Axios».
* _Реализация UserRepository_ (Adapter) уже использует конкретный ORM/HTTP-клиент. Но сам «домен» об этом не знает.

#### 2.4. Локализовать фреймворк-зависимые вызовы

* Если в React используем `useEffect`, `useState` — лучше держать их в компоненте или в **кастомном хуке**. Весь расчёт пусть делает чистая функция, не содержащая React-специфики.
* В Angular/Nest — сервисы с аннотациями `@Injectable()` пусть будут «обёртками», а настоящая бизнес-логика может жить в «чистом» модуле, который импортируется.

***

### 3. Примеры

#### 3.1. React-пример

**«Плохо» (логика «прилипла» к фреймворку)**

```tsx
function Checkout() {
  const [cart, setCart] = useState<Cart>({ items: [] });

  // Логика, связанная с React
  const addItem = (item: Item) => {
    // Логика пересчёта total «зашита» здесь
    const newTotal = cart.items.reduce((acc, i) => acc + i.price, 0) + item.price;
    setCart({ items: [...cart.items, item], total: newTotal });
  };

  // ...
  return (
    // ...
  );
}
```

* «addItem» содержит бизнес-логику (расчёт total) вместе с React setState.
* Трудно покрыть тестами без мака React-хука, плюс логика разбросана.

**«Хорошо» (отделяем доменную функцию от UI)**

```ts
// domain/cartService.ts
export function addToCart(cart: Cart, item: Item): Cart {
  const items = [...cart.items, item];
  const total = items.reduce((acc, i) => acc + i.price, 0);
  return { items, total };
}
```

```tsx
// components/Checkout.tsx
function Checkout() {
  const [cart, setCart] = useState<Cart>({ items: [], total: 0 });

  // «Адаптация» к React
  const handleAddItem = (item: Item) => {
    // Логика находится в "cartService.ts", 
    // здесь мы просто применяем её и обновляем стейт:
    const updated = addToCart(cart, item);
    setCart(updated);
  };

  return (
    <>
      {/* UI */}
    </>
  );
}
```

* _cartService_ не зависит от React: это «чистая» логика.
* _Checkout.tsx_ просто вызывает `addToCart` из домена, а затем вызывает `setCart`.

#### 3.2. NestJS-пример

```ts
// domain/userService.ts (Core)
export class UserService {
  createUser(name: string) {
    // какая-то бизнес-логика (валидация, правила)
    if (!name) throw new Error("Empty name");
    return { id: 1, name };
  }
}
```

```ts
// infrastructure/userController.ts (Framework code)
@Controller("users")
export class UserController {
  private userService = new UserService();

  @Post()
  create(@Body() dto: { name: string }) {
    // Здесь «склеиваем» HTTP-request с «Core»:
    return this.userService.createUser(dto.name);
  }
}
```

* «UserService» не знает о NestJS.
* «UserController» знает о Nest (декоратор `@Controller`, `@Post`), но просто вызывает метод доменной логики.

***

### 4. Когда (и почему) всё-таки можно «смешивать»?

Иногда целесообразно прямо в React-компоненте или Angular-сервисе оставить некоторую простую логику. Например:

* Совсем тривиальные вычисления, которые не переиспользуются больше нигде.
* Простой предикат (если `count > 0`), который не стоит выносить в отдельный модуль.

Но если логика растёт, становится сложно тестировать/поддерживать — тогда стоит «вынести» её в чистую часть.

**В целом**: придерживайтесь принципа «не смешивать» бизнес-правила с вызовами фреймворка (UI, DB, HTTP), если код явно выходит за рамки элементарной проверки/присвоения.

***

### Итог

**Keep Framework/Library Code Distant**:

1. **Минимизируйте** проникновение фреймворка в бизнес-логику (сохраняйте домен «чистым»).
2. Используйте **слои** или **адаптеры** для взаимодействия с внешним миром (UI, HTTP, DB).
3. Разделяйте **Core (домен)** и **Infrastructure (фреймворк)**.
4. Выигрыши: **тестируемость**, **легко менять инструменты**, **более гибкая архитектура**.

Такой подход **уменьшает связанность** и облегчает развитие приложения, позволяя вам менять/обновлять библиотеки и фреймворки без радикальных переделок всей системы.
